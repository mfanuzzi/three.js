<html lang="en">
<head>
	<title>MFMFMFMFS LSOOOOO</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #61443e;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;
			background-color: #bfd1e5;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {
			color: #a06851;
		}
	</style>
</head>
<body>
	<div id="info">Ammo.js physics soft body volume demo<br>Click to throw a ball</div>
	<div id="container"><br /><br /><br /><br /><br />Loading...</div>

	<script src="../build/three.js"></script>
	<script src="js/libs/ammo.js"></script>
	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/utils/BufferGeometryUtils.js"></script>
	<script src="js/WebGL.js"></script>
	<script src="js/loaders/GLTFLoader.js"></script>
	<script src="js/libs/stats.min.js"></script>
	<script src="js/postprocessing/EffectComposer.js"></script>
	<script src="js/postprocessing/RenderPass.js"></script>
	<script src="js/postprocessing/ShaderPass.js"></script>
	<script src="js/postprocessing/HalftonePass.js"></script>

	<script src="js/shaders/CopyShader.js"></script>
	<script src="js/shaders/HalftoneShader.js"></script>
	<script src="js/shaders/DepthLimitedBlurShader.js"></script>
	<script src="js/shaders/UnpackDepthRGBAShader.js"></script>

	<script src="js/geometries/ConvexGeometry.js"></script>
	<script src="js/QuickHull.js"></script>

	<script src="rayintersect.js"></script>
	<script src="int.js"></script>

	<script>

		if (WEBGL.isWebGLAvailable() === false) {

			document.body.appendChild(WEBGL.getWebGLErrorMessage());
			document.getElementById('container').innerHTML = "";

		}

		// Graphics variables
		var container, stats;
		var camera, controls, scene, renderer;
		var textureLoader;
		var clock = new THREE.Clock();
		var clickRequest = false;
		var mouseCoords = new THREE.Vector2();
		var raycaster = new THREE.Raycaster();
		var ballMaterial = new THREE.MeshPhongMaterial({ color: 0x202020 });
		var pos = new THREE.Vector3();
		var quat = new THREE.Quaternion();

		// Physics variables
		var gravityConstant = -90;
		var physicsWorld;
		var rigidBodies = [];
		var softBodies = [];
		var margin = 0.05;
		var transformAux1;
		var softBodyHelpers;
		var composer, renderPass, halftonePass, params;

		var cameraFacingThings = [];
		var collidableMeshList = [];
		var theThing;

		Ammo().then(function (AmmoLib) {

			Ammo = AmmoLib;

			init();
			animate();

		});

		function init() {

			initGraphics();

			initPhysics();

			createObjects();

			initInput();

		}

		function initGraphics() {

			container = document.getElementById('container');
			container.innerHTML = '';

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);

			camera.position.set(40, 5, 50);

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			container.appendChild(renderer.domElement);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 20, 0);
			controls.update();

			textureLoader = new THREE.TextureLoader();

			var ambientLight = new THREE.AmbientLight(0xaaaaaa);
			scene.add(ambientLight);

			var light = new THREE.DirectionalLight(0xffffff, 3); //light intensity
			light.position.set(- 10, 10, 5);
			light.castShadow = true;
			var d = 20;
			light.shadow.camera.left = - d;
			light.shadow.camera.right = d;
			light.shadow.camera.top = d;
			light.shadow.camera.bottom = - d;

			light.shadow.camera.near = 2;
			light.shadow.camera.far = 50;

			light.shadow.mapSize.x = 1024;
			light.shadow.mapSize.y = 1024;

			scene.add(light);

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild(stats.domElement);


			window.addEventListener('resize', onWindowResize, false);

			// post-processing
			composer = new THREE.EffectComposer(renderer);
			renderPass = new THREE.RenderPass(scene, camera);
			params = {
				shape: 1,
				radius: 3,
				rotateR: Math.PI / 12,
				rotateB: Math.PI / 12 * 2,
				rotateG: Math.PI / 12 * 3,
				scatter: 0,
				blending: 1,
				blendingMode: 1,
				greyscale: true,
				disable: false
			};
			halftonePass = new THREE.HalftonePass(window.innerWidth, window.innerHeight, params);
			composer.addPass(renderPass);
			composer.addPass(halftonePass);




		}

		function initPhysics() {

			// Physics configuration

			var collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
			var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
			var broadphase = new Ammo.btDbvtBroadphase();
			var solver = new Ammo.btSequentialImpulseConstraintSolver();
			var softBodySolver = new Ammo.btDefaultSoftBodySolver();
			physicsWorld = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
			physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant, 0));
			physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, gravityConstant, 0));

			transformAux1 = new Ammo.btTransform();
			softBodyHelpers = new Ammo.btSoftBodyHelpers();

		}

		function createObjects() {

			var mat = new THREE.ShaderMaterial({
				uniforms: {},
				vertexShader: [
					"varying vec2 vUV;",
					"varying vec3 vNormal;",
					"void main() {",
					"vUV = uv;",
					"vNormal = vec3( normal );",
					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
					"}"
				].join("\n"),
				fragmentShader: [
					"varying vec2 vUV;",
					"varying vec3 vNormal;",
					"void main() {",
					"vec4 c = vec4( abs( vNormal ) + vec3( vUV, 0.0 ), 0.0 );",
					"gl_FragColor = c;",
					"}"
				].join("\n")
			});


			//// Ground (fake)
			//var fakeGround = new THREE.Mesh(new THREE.PlaneGeometry(30, 30, 32, 32), new THREE.MeshBasicMaterial({ color: 0xdddddd, side: THREE.DoubleSide }));
			//fakeGround.rotation.x = Math.PI / 2;
			////scene.add(fakeGround);
			////console.log(fakeGround);
			//collidableMeshList.push(fakeGround);

			// Ground (hard)
			pos.set(0, -1, 0);
			quat.set(0, 0, 0, 1);
			var ground = createParalellepiped(40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xDDDDDD }));
			ground[0].castShadow = false;
			ground[0].receiveShadow = true;
			ground[0].material.color.setHex(0x888888);
			/*textureLoader.load("textures/grid.png", function (texture) {

				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set(40, 40);
				ground.material.color.setHex(0x000000);

			});
			*/

			// Create rigid eye
			var eyeMass = 0;
			var eyeRadius = 2;

			eye = new THREE.Mesh(new THREE.SphereBufferGeometry(eyeRadius, 24, 10), new THREE.MeshPhongMaterial({ color: 0xFFFFFF }));
			eye.scale.x = 1.7;
			eye.castShadow = true;
			eye.receiveShadow = false;

			textureLoader.load("textures/eye.jpg", function (texture) {

				eye.material.map = texture;
				eye.material.map.offset.x = .25;
				eye.material.map.offset.y = .1;
				eye.material.needsUpdate = true;
			});


			var eyeShape = new Ammo.btSphereShape(eyeRadius);
			console.log(eyeShape);
			eyeShape.setMargin(margin);
			//pos.copy(raycaster.ray.direction);
			//pos.add(raycaster.ray.origin);
			pos.y = 25;
			quat.set(0, 0, 0, 1);
			//var eyeBody = createRigidBody(eye, eyeShape, eyeMass, pos, quat);
			//eyeBody.setFriction(0.9);
			console.log(pos);
			//cameraFacingThings.push(eyeBody);

			// Create soft volumes
			var volumeMass = 15;

			var loader = new THREE.GLTFLoader();

			loader.load("models/gltf/eyees.glb", function (gltf) {

				//mesheye = gltf.scene.children[3];
				//scene.add( mesheye );


				mesh = gltf.scene.children[2];
				mesh.position.set(2, 30, 0);
				mesh.scale.set(5, 5, 5);
				mesh.rotation.set(.5, 0, 0);

				// apply the transform
				mesh.updateMatrix();
				mesh.geometry.applyMatrix(mesh.matrix);
				mesh.scale.set(1, 1, 1);
				mesh.updateMatrix();

				var thing = createSoftVolume(mesh.geometry, 9, 40);
				theThing = thing;
				console.log(thing);

				window.setTimeout(function () {
					//rayCollide(theThing, collidableMeshList);
					getPointsBelowY(theThing, 0);
					scene.remove(ground[0]);
				}, 5000);

			});


		}

		function processGeometry(bufGeometry) {

			// Ony consider the position values when merging the vertices
			var posOnlyBufGeometry = new THREE.BufferGeometry();
			posOnlyBufGeometry.addAttribute('position', bufGeometry.getAttribute('position'));
			posOnlyBufGeometry.setIndex(bufGeometry.getIndex());

			// Merge the vertices so the triangle soup is converted to indexed triangles
			var indexedBufferGeom = THREE.BufferGeometryUtils.mergeVertices(posOnlyBufGeometry);

			// Create index arrays mapping the indexed vertices to bufGeometry vertices
			mapIndices(bufGeometry, indexedBufferGeom);

		}

		function isEqual(x1, y1, z1, x2, y2, z2) {

			var delta = 0.000001;
			return Math.abs(x2 - x1) < delta &&
				Math.abs(y2 - y1) < delta &&
				Math.abs(z2 - z1) < delta;

		}

		function mapIndices(bufGeometry, indexedBufferGeom) {

			// Creates ammoVertices, ammoIndices and ammoIndexAssociation in bufGeometry

			var vertices = bufGeometry.attributes.position.array;
			var idxVertices = indexedBufferGeom.attributes.position.array;
			var indices = indexedBufferGeom.index.array;

			var numIdxVertices = idxVertices.length / 3;
			var numVertices = vertices.length / 3;

			bufGeometry.ammoVertices = idxVertices;
			bufGeometry.ammoIndices = indices;
			bufGeometry.ammoIndexAssociation = [];

			for (var i = 0; i < numIdxVertices; i++) {

				var association = [];
				bufGeometry.ammoIndexAssociation.push(association);

				var i3 = i * 3;

				for (var j = 0; j < numVertices; j++) {

					var j3 = j * 3;
					if (isEqual(idxVertices[i3], idxVertices[i3 + 1], idxVertices[i3 + 2],
						vertices[j3], vertices[j3 + 1], vertices[j3 + 2])) {

						association.push(j3);

					}

				}

			}

		}

		function createSoftVolume(bufferGeom, mass, pressure) {

			processGeometry(bufferGeom);

			var volume = new THREE.Mesh(bufferGeom, new THREE.MeshPhongMaterial({ color: 0xFFFFFF }));
			volume.castShadow = true;
			volume.receiveShadow = true;
			volume.frustumCulled = false;
			scene.add(volume);

			textureLoader.load("textures/eye.jpg", function (texture) {

				volume.material.map = texture;
				volume.material.map.offset.x = .25;
				volume.material.map.offset.y = .1;
				volume.material.needsUpdate = true;
				console.log(volume.material);

			});

			// Volume physic object

			var volumeSoftBody = softBodyHelpers.CreateFromTriMesh(
				physicsWorld.getWorldInfo(),
				bufferGeom.ammoVertices,
				bufferGeom.ammoIndices,
				bufferGeom.ammoIndices.length / 3,
				true);

			var sbConfig = volumeSoftBody.get_m_cfg();
			sbConfig.set_viterations(40);
			sbConfig.set_piterations(40);

			// Soft-soft and soft-rigid collisions
			sbConfig.set_collisions(0x11);

			// Friction
			sbConfig.set_kDF(0.1);
			// Damping
			sbConfig.set_kDP(0.01);
			// Pressure
			sbConfig.set_kPR(pressure);
			// Stiffness
			volumeSoftBody.get_m_materials().at(0).set_m_kLST(0.9);
			volumeSoftBody.get_m_materials().at(0).set_m_kAST(0.9);

			volumeSoftBody.setTotalMass(mass, false);
			Ammo.castObject(volumeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(margin);
			physicsWorld.addSoftBody(volumeSoftBody, 1, - 1);
			volume.userData.physicsBody = volumeSoftBody;
			// Disable deactivation
			volumeSoftBody.setActivationState(4);

			softBodies.push(volume);

			return volume;
		}

		function createParalellepiped(sx, sy, sz, mass, pos, quat, material) {

			var threeObject = new THREE.Mesh(new THREE.BoxBufferGeometry(sx, sy, sz, 1, 1, 1), material);
			var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
			shape.setMargin(margin);

			var rb = createRigidBody(threeObject, shape, mass, pos, quat);

			return [threeObject, rb];

		}

		function createRigidBody(threeObject, physicsShape, mass, pos, quat) {

			threeObject.position.copy(pos);
			threeObject.quaternion.copy(quat);

			var transform = new Ammo.btTransform();
			transform.setIdentity();
			transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
			transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
			var motionState = new Ammo.btDefaultMotionState(transform);

			var localInertia = new Ammo.btVector3(0, 0, 0);
			physicsShape.calculateLocalInertia(mass, localInertia);

			var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
			var body = new Ammo.btRigidBody(rbInfo);

			threeObject.userData.physicsBody = body;

			scene.add(threeObject);

			if (mass > 0) {

				rigidBodies.push(threeObject);

				// Disable deactivation
				body.setActivationState(4);

			}

			physicsWorld.addRigidBody(body);

			return body;

		}

		function initInput() {

			window.addEventListener('mousedown', function (event) {

				if (!clickRequest) {

					mouseCoords.set(
						(event.clientX / window.innerWidth) * 2 - 1,
						- (event.clientY / window.innerHeight) * 2 + 1
					);

					clickRequest = true;

				}

			}, false);

		}

		function processClick() {

			if (clickRequest) {

				raycaster.setFromCamera(mouseCoords, camera);

				// Creates a ball
				var ballMass = 3;
				var ballRadius = 0.4;

				ball = new THREE.Mesh(new THREE.SphereBufferGeometry(ballRadius, 18, 16), ballMaterial);
				ball.castShadow = true;
				ball.receiveShadow = true;

				var ballShape = new Ammo.btSphereShape(ballRadius);
				ballShape.setMargin(margin);
				pos.copy(raycaster.ray.direction);
				pos.add(raycaster.ray.origin);
				quat.set(0, 0, 0, 1);
				var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);
				ballBody.setFriction(0.5);

				pos.copy(raycaster.ray.direction);
				pos.multiplyScalar(14);
				ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));

				clickRequest = false;

			}

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {

			requestAnimationFrame(animate);

			render();
			stats.update();

		}

		function render() {

			var deltaTime = clock.getDelta();

			// Make thing face camera
			for (var i = 0, il = cameraFacingThings.length; i < il; i++) {
				cameraFacingThings[i].lookAt(camera.position);
			}


			updatePhysics(deltaTime);

			processClick();

			renderer.render(scene, camera);
			//composer.render( deltaTime );

		}

		function updatePhysics(deltaTime) {

			// Step world
			physicsWorld.stepSimulation(deltaTime, 10);

			// Update soft volumes
			for (var i = 0, il = softBodies.length; i < il; i++) {

				var volume = softBodies[i];
				var geometry = volume.geometry;
				var softBody = volume.userData.physicsBody;
				var volumePositions = geometry.attributes.position.array;
				var volumeNormals = geometry.attributes.normal.array;
				var association = geometry.ammoIndexAssociation;
				var numVerts = association.length;
				var nodes = softBody.get_m_nodes();
				for (var j = 0; j < numVerts; j++) {

					var node = nodes.at(j);
					var nodePos = node.get_m_x();
					var x = nodePos.x();
					var y = nodePos.y();
					var z = nodePos.z();
					var nodeNormal = node.get_m_n();
					var nx = nodeNormal.x();
					var ny = nodeNormal.y();
					var nz = nodeNormal.z();

					var assocVertex = association[j];

					for (var k = 0, kl = assocVertex.length; k < kl; k++) {

						var indexVertex = assocVertex[k];
						volumePositions[indexVertex] = x;
						volumeNormals[indexVertex] = nx;
						indexVertex++;
						volumePositions[indexVertex] = y;
						volumeNormals[indexVertex] = ny;
						indexVertex++;
						volumePositions[indexVertex] = z;
						volumeNormals[indexVertex] = nz;

					}

				}

				geometry.attributes.position.needsUpdate = true;
				geometry.attributes.normal.needsUpdate = true;

			}

			// Update rigid bodies
			for (var i = 0, il = rigidBodies.length; i < il; i++) {

				var objThree = rigidBodies[i];
				var objPhys = objThree.userData.physicsBody;
				var ms = objPhys.getMotionState();
				if (ms) {

					ms.getWorldTransform(transformAux1);
					var p = transformAux1.getOrigin();
					var q = transformAux1.getRotation();
					objThree.position.set(p.x(), p.y(), p.z());
					objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());

				}

			}

		}

	</script>

</body>
</html>
