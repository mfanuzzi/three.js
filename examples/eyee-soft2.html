<html lang="en">
<head>
	<title>ｕｎｉｍａｇｉｎａｂｌｅ, 𝕤𝕦𝕡𝕖𝕣𝕔𝕠𝕤𝕞𝕚𝕔, 🇪🇹🇪🇷🇳🇦🇱 🇸🇴🇲🇪🇹🇭🇮🇳🇬🇸 [LB011]</title>
	<meta charset="utf-8">
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<link rel="shortcut icon" type="image/png" href="https://lazerbea.ms/img/favicon128.png" />
	<link rel="manifest" href="manifest.json">

	<!-- Open Graph data -->
	<meta property="og:title" content="unimaginable, supercosmic, eternal somethings [LB011]" />
	<meta property="og:site_name" content="lazerbea.ms" />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="https://lazerbea.ms/lb011" />
	<meta property="og:image" content="https://lazerbea.ms/lb011/card.png" />
	<meta property="og:description" content="eternal-falling transmogrification study for morpheme-based beings (based upon actual events)" />

	<meta name="description" content="eternal-falling transmogrification study for morpheme-based beings (based upon actual events)">
	<style>

		@font-face {
			font-family: Adventor;
			src: url(https://lazerbea.ms/fonts/texgyreadventor-regular-webfont.woff) format("woff");
			font-weight: 400;
			font-style: normal
		}

		@font-face {
			font-family: Adventor;
			src: url(https://lazerbea.ms/fonts/texgyreadventor-italic-webfont.woff) format("woff");
			font-weight: 400;
			font-style: italic
		}

		@font-face {
			font-family: Adventor;
			src: url(https://lazerbea.ms/fonts/texgyreadventor-bold-webfont.woff) format("woff");
			font-weight: 700;
			font-style: normal
		}

		@font-face {
			font-family: Adventor;
			src: url(https://lazerbea.ms/fonts/texgyreadventor-bolditalic-webfont.woff) format("woff");
			font-weight: 700;
			font-style: italic
		}

		body {
			color: #000;
			font-family: 'Century Gothic',Adventor,sans-serif;
			font-size: 3vw;
			text-align: center;
			background-color: #fff;
			margin: 0px;
			cursor: grab;
			overflow-x: hidden;
		}

		@media (orientation: portrait) {
			body {
				font-size: 6vw;
			}
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {
			color: #a06851;
		}

		#container {
			width: 100%;
			height: 100%;
		}

		#welcome {
			position: absolute;
			top: 0;
			left: 0;
			z-index: 69;
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: column;
			background-color: #fff;
			filter: grayscale(1);
		}

		#welcome:after {
			display: block;
			width: 100%;
			height: 100%;
			position: absolute;
			content: '';
			background: linear-gradient(#fff, #9198e5);
			opacity: .3;
		}

		#welcome > div:first-child {
			height: 25%;
		}

		#logo {
			background: url('https://lazerbea.ms/img/logo.svg') no-repeat 0 bottom;
			background-size: auto 100%;
		}

		@media (orientation: portrait) {
			/*#welcome > div:first-child {
				height: 15%;
			}*/
			#logo {
				background-position: right 11vw bottom;
			}
		}

		#loadin {
			background-color: #d21888;
			color: #fff;
			padding: 1em;
		}

		#loadin p {
			margin: 0;
		}

		button {
			padding-right: 1.72209em;
			padding-bottom: 1.06431em;
			font-size: 2.12862em;
			width: calc(100% - 2em);
			background-color: #18d1bd;
			color: #fff;
			animation: 2s infinite alternate gloooo;
			text-shadow: .05em 0.25em 0px black;
			border-width: .5em;
			position: absolute;
			z-index: 666;
			left: 1em;
		}

		button:hover {
			color: #000;
			cursor: grabbing;
			animation-duration: .2s;
		}

		@keyframes gloooo {
			0% {
				background-color: #18d1bd;
			}

			50% {
				background-color: #d21888;
			}

			100% {
				background-color: #18d1bd;
			}
		}

		#begin {
			margin-top: .25em;
		}

		#huh {
			width: auto;
			font-size: 1.618em;
			text-align: center;
			padding: 0;
			top: 0;
			font-size: 2vw;
			border-width: 1em;
		}

		#creds {
			position: absolute;
			padding: 1em 1em 0 1em;
			top: 2em;
			left: 11vw;
			background: linear-gradient(#fff, #9198e5);
			height: auto !important;
			z-index: 666;
			display: none;
			color: #fff;
		}

		#creds ul {
			padding-left: .5em;
		}

		.creds #creds {
			display: block;
		}

		#loadMsg {
			display: none;
		}

		.loading #loadMsg {
			display: inline;
		}

		.loading #begin {
			display: none;
		}

		.loading #huh {
			display: none;
		}

		.loading #creds {
			display: none;
		}

		.start {
			overflow: hidden;
		}

		@media (orientation: portrait) {
			#huh {
				font-size: 5vw;
			}
		}

		ul.mobile {
			display: none;
		}

		body.mobile ul.mobile {
			display: block;
		}

		body.mobile ul.desktop {
			display: none;
		}
	</style>
</head>
<body class="loading">
	<div id="container">
	</div>
	<div id="welcome">
		<div id="logo"></div>
		<div id="loadin">
			<p>
				<span style="text-shadow: -.1em .1em black">LB011</span>
				<br /><em style="letter-spacing: .5em">&ldquo;unimaginable, supercosmic, eternal somethings</em>&rdquo;
			</p>
			<p>
				<span id="loadMsg">𝚕𝚘𝚊𝚍𝚒𝚗𝚐...</span>
				<button id="begin">begin feel</button>
				<button id="huh">?</button>
			</p>
		</div>
		<div id="creds">
			<p>
				eternal falling.<br />
				based upon actual events &amp; a dream about endless space / infinite renewal.
			</p>
			<ul class="desktop">
				<li>double-click or space to <strong>capture a moment</strong>.</li>
				<li>press any other key to <strong>see a new perspective</strong>.</li>
			</ul>
			<ul class="mobile">
				<li>tap three (3) fingers to <strong>see a new perspective</strong>.</li>
				<li>tap four (4) fingers to <strong>capture a moment</strong>.</li>
			</ul>
			<p>
				by <a href="https://lazerbea.ms">lazerbea.ms</a>
			</p>
		</div>
	</div>

	<script src="js/three.min.js"></script>
	<script src="eyelib.js"></script>

	<!--<script src="js/libs/ammo.js"></script>
	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/utils/BufferGeometryUtils.js"></script>
	<script src="js/WebGL.js"></script>
	<script src="js/loaders/GLTFLoader.js"></script>
	<script src="js/postprocessing/EffectComposer.js"></script>
	<script src="js/postprocessing/RenderPass.js"></script>
	<script src="js/postprocessing/ShaderPass.js"></script>
	<script src="js/postprocessing/HalftonePass.js"></script>
	<script src="js/postprocessing/AfterimagePass.js"></script>

	<script src="js/shaders/CopyShader.js"></script>
	<script src="js/shaders/HalftoneShader.js"></script>
	<script src="js/shaders/AfterimageShader.js"></script>

	<script src="js/geometries/ConvexGeometry.js"></script>
	<script src="js/math/ConvexHull.js"></script>

	<script src="js/modifiers/SimplifyModifier.js"></script>

	<script src="js/tone.js"></script>
	<script src="js/teoria.js"></script>-->

	<script src="js/FileSaver.min.js"></script>

	<script src="js/screenfull.min.js"></script>

	<script>

		if (THREE.WEBGL.isWebGLAvailable() === false) {
			document.getElementById('loadin').appendChild(THREE.WEBGL.getWebGLErrorMessage());
			document.getElementById('container').innerHTML = "";
		}

		// Graphics variables
		var container; //, stats;
		var camera, controls, scene, renderer;
		var textureLoader;
		const clock = new THREE.Clock();
		const clockFPS = new THREE.Clock();
		var clickRequest = false;
		var mouseCoords = new THREE.Vector2();
		var raycaster = new THREE.Raycaster();
		var volumeMat, volumeMatOld;
		var initialMesh;
		var pos = new THREE.Vector3();
		var quat = new THREE.Quaternion();

		// Physics variables
		var gravityConstant = -13;
		var gravX = 0;
		var gravZ = 0;
		var slowGravity;
		var normalGravity;

		var physicsWorld;
		var rigidBodies = [];
		var softBodies = [];
		var margin = 0.05;
		var transformAux1;
		var softBodyHelpers;
		var composer, renderPass, halftonePass, afterimagePass, params;
		var cameraFacingThings = [];

		var theThings = [];
		var ground;
		var eye = [null, null, null, null];
		var eyeTexture;

		var intersectionals = [];

		var startingAzimuth = 0;

		var collisionCount = 0;

		var lastX = 0;
		var lastY = 0;

		var isControllingOrbit = false;
		var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

		// audio variables
		var reverb;

		function handleOrientation(event) {
			// Range of beta/gamma is -180 to 180
			var x = event.gamma;  // In degree in the range [-180,180] -- up/down
			var y = event.beta; // In degree in the range [-90,90] -- left/right

			//output.innerHTML  = "beta : " + x + "\n";
			//output.innerHTML += "gamma: " + y + "\n";

			// Because we don't want to have the device upside down
			// We constrain the x value to the range [-90,90]
			if (x > 90) { x = 90 };
			if (x < -90) { x = -90 };
			if (y > 90) { y = 90 };
			if (y < -90) { y = -90 };

			x = x * (Math.PI / 180);
			y = y * (Math.PI / 180);

			var diff = Math.abs(lastX) - Math.abs(x);
			if (x < 0)
				controls.rotateL(-diff);
			else
				controls.rotateL(diff);

			var diff = Math.abs(lastY) - Math.abs(y);
			if (y < 0)
				controls.rotateU(-diff);
			else
				controls.rotateU(diff);

			lastX = x;
			lastY = y;
		}

		//version one: 3 half-steps clockwise out from center
		//const notemap = [
		//	['F3','F#3','G3','G#3','A4','A#4'],
		//	['E3','D#2','E2','F2','F#2','B4'],
		//	['D#3','D2','A2','A#2','G2','C4'],
		//	['D3','C#2','C2','B2','G#2','C#4'],
		//	['C#3','C3','B3','A#3','A3','D4'],
		//	['G#4','G4','F#4','F4','E4','D#4']
		//];

		//v2: skipping up-to-right, meh
		//const notemap = [
		//	['A2','C3','F2','G#3','A4','A#4'],
		//	['A3','C2','F3','G#2','F#2','B4'],
		//	['B2','D3','G2','D#3','G2','C4'],
		//	['B3','D2','G3','D#2','G#2','C#4'],
		//	['C#2','E3','A#2','F#3','A3','D4'],
		//	['C#3','E2','A#3','F#2','E4','D#4']
		//];

		//v3: chromatic at edges, Fmaj7 center, minor filling
		const notemapInit = [
			['A3', 'A#3', 'B3', 'C3', 'C#3', 'D3'],
			['E3', 'G4', 'D4', 'A4', 'E4', 'D#3'],
			['D#', 'C4', 'E5', 'F5', 'B4', 'E3'],
			['D3', 'F4', 'C5', 'A5', 'F#4', 'F3'],
			['C#3', 'A#4', 'D#4', 'G#4', 'C#4', 'F#3'],
			['C3', 'B3', 'A#3', 'A3', 'G#3', 'G3']
		];
		var notemap = JSON.parse(JSON.stringify(notemapInit));
		var notemaphi = [
			['A7', 'A#7', 'B7', 'C7', 'C#7', 'D7'],
			['E7', 'G6', 'D6', 'A6', 'E6', 'D#7'],
			['D#', 'C6', 'E7', 'F7', 'B6', 'E7'],
			['D7', 'F6', 'C7', 'A7', 'F#6', 'F7'],
			['C#7', 'A#6', 'D#6', 'G#6', 'C#6', 'F#7'],
			['C7', 'B7', 'A#7', 'A7', 'G#7', 'G7']
		];

		// some interesting camera positions (taken at full-width desktop; do we transform these somehow for the more limited scope of mobile?)
		var cameraPositions = [
			new THREE.Vector3(-4, 70, 10),
			new THREE.Vector3(42, -13, 41),
			new THREE.Vector3(-3.4, 2.5, 34),
			new THREE.Vector3(-4, 38, 29),
			new THREE.Vector3(41, 18, 26),
			new THREE.Vector3(-6.6, 34, 25)
		];

		// titles for screenshots, selected randomly
		const screenshotTitles = [
			'unimaginable',
			'supercosmic',
			'eternal',
			'somethings',
			'lazerbeams'
		];

		var lastCollisionTimeout = null;
		var synth;
		function handleCollision(event) {
			// Determine the "volume" of the geometry to set how much velocity the hit should have
			if (event.detail.co.geometry.boundingBox == null)
				event.detail.co.geometry.computeBoundingBox();
			const bbSize = event.detail.co.geometry.boundingBox.getSize();
			const bbVol = bbSize.x * bbSize.y * bbSize.z;

			let bbNoteVel = (bbVol / 1000);
			if (bbNoteVel > 1) bbNoteVel = 1;
			if (bbNoteVel < .1) bbNoteVel = .1;

			if (Math.ceil((collisionCount + 1) / 10) % 2 === 0) {
				playNoteFromXZ(event.detail.at.x, event.detail.at.z, notemap, bbNoteVel, true, synth, ((collisionCount % 10) / 10) * 3 + .1);
			}

			// If this is the first collision of the set...
			if (event.detail.first === true) {
				// perhaps every cycle of 10x2, we should shuffle the pitches?
				// (the problem is this happens for each hit, of course)
				if (collisionCount % 20 === 0) {
					reverb.roomSize.rampTo(.9, '3s')
					setTimeout(() => {
						//synth.releaseAll(); // this may no longer be neccesary
						reverb.roomSize.rampTo(1.2, '2s')
					}, 4000);
					determineNewPitches();
				}
			}

			// the below ensures that we have a way to auto-reset even if everything falls off the stage
			if (lastCollisionTimeout)
				clearTimeout(lastCollisionTimeout);

			lastCollisionTimeout = setTimeout(handleCollisionTimeout, 20000);
		}

		// This is basically to ensure that if the thing misses the stage completely, we have a way of getting it running again
		function handleCollisionTimeout() {
			createEye();
		}

		const sixnotechords = [
			'sus2#5b11',
			'maj11',
			'sus12maj9',
			'min11b5',
			'#12'
		];
		const scales = [
			'dorian',
			'phrygian',
			//'locrian', // this is too 'major'
			'melodicminor'
		]
		function getRandomInt(min, max) {
			min = Math.ceil(min);
			max = Math.floor(max);
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}
		function determineNewPitches() {
			// Make the whole stage one scale
			let tonic = new teoria.note(notemap[2][2]);
			if (tonic.key() > 60)
				tonic = teoria.note.fromKey(tonic.key() - 12);

			const scaleName = scales[getRandomInt(0, scales.length - 1)];
			console.log(scaleName);
			const scale = tonic.scale(scaleName).notes();
			for (let i = 0; i < notemap.length; i++) {
				for (let j = 0; j < notemap[i].length; j++) {
					notemap[i][j] = scale[getRandomInt(0, 6)].toString();
				}
			}
			tonic = null

			//// Take the middle note as the future tonic (TODO: instead make this the most popular note maybe?)
			////const tonic = new teoria.note(notemap[2][2]);

			//for (var i = 0; i < notemap.length; i++) {
			//	var tonic = new teoria.note(notemap[i][2]);
			//	if (tonic.key() > 72) //g#6
			//		tonic = teoria.note.fromKey(tonic.key() - 24);
			//	console.log(tonic);
			//	const scale = tonic.chord(sixnotechords[getRandomInt(0, sixnotechords.length - 1)]).notes();
			//	console.log(scale);
			//	for (var j = 0; j < notemap[i].length; j++) {
			//		notemap[i][j] = scale[j].toString();
			//	}
			//}

			// Make the 'hi' version that is just the above + 2 octaves
			for (let i = 0; i < notemap.length; i++) {
				for (let j = 0; j < notemap[i].length; j++) {
					let t = new teoria.note(notemap[i][j]);
					notemaphi[i][j] = teoria.note.fromKey(t.key() + 24).toString()
					t = null;
				}
			}

			//// Raise everything by a M2
			//for (var i = 0; i < notemap.length; i++) {
			//	for (var j = 0; j < notemap[i].length; j++) {
			//		var t = teoria.note(notemap[i][j]);
			//		notemap[i][j] = t.interval('M2').toString();
			//		notemaphi[i][j] = t.interval('M16').toString();
			//	}
			//}
		}

		function playNoteFromXZ(x, z, nmap, velocity, detune, syn, sec) {
			let eX = Math.round((x / 20) * 3);
			let eZ = Math.round((z / 20) * 3);

			eX += 2; //2 instead of 3 because zero-based array
			eZ += 2;

			if (eX > nmap.length - 1) eX = nmap.length - 1;
			if (eZ > nmap.length - 1) eZ = nmap.length - 1;
			if (eX < 0) eX = 0;
			if (eZ < 0) eZ = 0;

			//console.log(eX + ',' + eZ + ' from ' + x + ',' + z);

			syn.set("detune", 0);
			syn.triggerAttackRelease(nmap[eX][eZ], sec + 's', undefined, velocity);

			if (detune === true) {
				setTimeout(function () {
					syn.set("detune", -400, 10);
				}, 2000);
			}
		}

		window.addEventListener('deviceorientation', handleOrientation);

		window.addEventListener('collision', handleCollision);


		Ammo().then(function (AmmoLib) {

			Ammo = AmmoLib;

			init();
		});

		function groupBy(objectArray, property) {
			return objectArray.reduce(function (acc, obj) {
				var key = obj[property];
				if (!acc[key]) {
					acc[key] = [];
				}
				acc[key].push(obj);
				return acc;
			}, {});
		}

		function init() {
			initDOM();

			initSound();

			initGraphics();

			// initPhysics(); // Now called from initGraphics

			//createObjects(); // Now called upon user input

			// initInput(); // Now called from initPhysics

		}

		function initDOM() {
			if (isMobile)
				document.body.classList.add('mobile');
		}

		function initSound() {
			Tone.Master.volume.value = -99; // without setting this, Chrome seems to crack up. like, too much.

			reverb = new Tone.JCReverb(.2);
			let wide = new Tone.StereoWidener(.8).toMaster();
			let narrow = new Tone.StereoWidener(.2).toMaster();
			synth = new Tone.PolySynth(5, Tone.Synth).chain(narrow);
			synth2 = new Tone.PolySynth(5, Tone.Synth).chain(wide);
			synth2.voices.forEach(v => v.portamento = 2);

			synth.volume = -8;
			synth2.volume = -2;
			let masterCompressor = new Tone.Compressor({
				"threshold": -6,
				"ratio": 8,
				"attack": 0.5,
				"release": 0.1
			});
			Tone.Master.chain(reverb, masterCompressor);
		}

		function initGraphics() {

			container = document.getElementById('container');
			container.innerHTML = '';

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);

			camera.position.set(-4, 70, 10);
			//camera.rotation.set()
			//camera.rotation.order = 'YXZ';
			//camera.rotation.x = -1.5;

			renderer = new THREE.WebGLRenderer({
				preserveDrawingBuffer: true // to enable saving images -- performance hit tho
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			container.appendChild(renderer.domElement);

			renderer.domElement.addEventListener('touchstart', handleMultiTouch);
			renderer.domElement.addEventListener('touchend', handleMultiTouch);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target.set(0, -10, 0);
			controls.update();
			startingAzimuth = controls.getAzimuthalAngle();
			//controls.enabled = false;
			controls.enableZoom = true;
			controls.enablePan = false;
			controls.maxDistance = 120;
			controls.minDistance = 30;

			// Load textures
			textureLoader = new THREE.TextureLoader();
			eyeTexture = textureLoader.load("textures/eye.jpg");

			// Material for soft bodies
			volumeMat = new THREE.MeshLambertMaterial({ color: 0x55eeff, opacity: 0.5, transparent: true }); //old
			//var volumeMat = new THREE.MeshPhongMaterial({ color: 0x00ffff, opacity: 0.5, transparent: true, shininess : 100 });
			volumeMatOld = volumeMat.clone();

			volumeMat.map = eyeTexture;
			volumeMat.map.offset.x = .25;
			volumeMat.map.offset.y = .1;
			//volume.material.needsUpdate = true;
			//console.log(volume.material);
			volumeMatOld.map = volumeMat.map;

			var ambientLight = new THREE.AmbientLight(0xaaaaaa);
			scene.add(ambientLight);

			var light = new THREE.DirectionalLight(0xffffff, 10); //light intensity
			light.position.set(- 10, 30, 5);
			light.castShadow = true;
			let d = 20;
			light.shadow.camera.left = - d;
			light.shadow.camera.right = d;
			light.shadow.camera.top = d;
			light.shadow.camera.bottom = - d;

			light.shadow.camera.near = 2;
			light.shadow.camera.far = 50;

			light.shadow.mapSize.x = 1024;
			light.shadow.mapSize.y = 1024;

			scene.add(light);

			window.addEventListener('resize', onWindowResize, false);

			// post-processing
			composer = new THREE.EffectComposer(renderer);
			renderPass = new THREE.RenderPass(scene, camera);
			params = {
				shape: 1,
				radius: 3,
				rotateR: Math.PI / 12,
				rotateB: Math.PI / 12 * 2,
				rotateG: Math.PI / 12 * 3,
				scatter: 0,
				blending: .2,
				blendingMode: 2,
				greyscale: true,
				disable: false
			};
			halftonePass = new THREE.HalftonePass(renderer.getSize().x, renderer.getSize().y, params);
			afterimagePass = new THREE.AfterimagePass();
			composer.addPass(renderPass);
			composer.addPass(halftonePass);
			composer.addPass(afterimagePass);

			// Load model(s)
			// TODO: this should be done with promises...
			var gloader = new THREE.GLTFLoader();

			gloader.load("models/gltf/eyeees.glb", function (gltf) {

				let mesh = gltf.scene.children[2];
				mesh.position.set(2, 60, 0);
				//mesh.position.y = 30;
				mesh.scale.set(5, 5, 5);
				mesh.rotation.set(1, 0, 0);

				// apply the transform
				mesh.updateMatrix();
				mesh.geometry.applyMatrix(mesh.matrix);
				mesh.scale.set(1, 1, 1);
				mesh.updateMatrix();

				initialMesh = mesh;

				initPhysics();
			});
		}

		function initPhysics() {

			// Physics configuration
			slowGravity = new Ammo.btVector3(0, gravityConstant / 4, 0);
			normalGravity = new Ammo.btVector3(0, gravityConstant, 0);

			var collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
			var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
			var broadphase = new Ammo.btDbvtBroadphase();
			var solver = new Ammo.btSequentialImpulseConstraintSolver();
			var softBodySolver = new Ammo.btDefaultSoftBodySolver();
			physicsWorld = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
			physicsWorld.setGravity(normalGravity);
			physicsWorld.getWorldInfo().set_m_gravity(normalGravity);

			transformAux1 = new Ammo.btTransform();
			softBodyHelpers = new Ammo.btSoftBodyHelpers();

			initInput();
		}

		function createEye(meshToTarget) {
			// Create rigid eye
			const eyeMass = 5;
			const eyeRadius = 2;

			// remove last round's old eyes
			if (eye[2] !== null && eye[3] !== null) {
				scene.remove(eye[2]);
				scene.remove(eye[3]);
				physicsWorld.removeRigidBody(eye[2].userData.physicsBody, true);
				physicsWorld.removeRigidBody(eye[3].userData.physicsBody, true);
				rigidBodies.splice(rigidBodies.indexOf(eye[2]), 1);
				rigidBodies.splice(rigidBodies.indexOf(eye[3]), 1);
				eye[2].geometry.dispose();
				eye[3].geometry.dispose();
				eye[2] = null;
				eye[3] = null;
			}

			// save old eyes
			eye[3] = eye[1];
			eye[2] = eye[0];

			for (let i = 0; i < 2; i++) {
				eye[i] = new THREE.Mesh(new THREE.SphereBufferGeometry(eyeRadius, 24, 10), new THREE.MeshPhongMaterial({ color: 0xFFFFFF }));
				eye[i].pointColor = '#ff0427';
				eye[i].scale.x = 1.7;
				//eye[i].rotateOnAxis(.1);
				eye[i].castShadow = true;
				eye[i].receiveShadow = false;
				eye[i].material.map = eyeTexture;
				eye[i].material.map.offset.x = .25;
				eye[i].material.map.offset.y = .1;
				eye[i].material.needsUpdate = true;
				let eyeShape = new Ammo.btSphereShape(eyeRadius);
				eyeShape.setMargin(margin);

				let ipos = new THREE.Vector3();
				let iquat = new THREE.Quaternion();
				ipos.set(0, 20, 0);
				//iquat.set(0, 0, .25 * (i % 2 === 0 ? -1 : 1), 1);
				iquat.set(0, 0, 0, 1);

				if (meshToTarget) {
					meshToTarget.geometry.computeBoundingBox();
					var center = new THREE.Vector3();
					meshToTarget.geometry.boundingBox.getCenter(center);
					meshToTarget.localToWorld(center);
					ipos = center;
					ipos.y = 95;
				}

				// space out the second eye
				ipos.y += (1.2 * i);
				ipos.x += (6.5 * i);
				ipos.z += (1.3 * i);

				let eyeBody = createRigidBody(eye[i], eyeShape, eyeMass, ipos, iquat);
				eyeBody.setFriction(0.8);
				eyeBody.applyLocalTorque(new Ammo.btVector3(0, 0, 3 * (i % 2 === 0 ? -1 : 1)))

				playNoteFromXZ(ipos.x, ipos.z, notemaphi, 0.1, false, synth2, 8);
			}

			//cameraFacingThings.push(eyeBody);
		}

		function createObjects() {

			// Ground (hard)
			pos.set(0, -1, 0);
			quat.set(0, 0, 0, 1);
			ground = createParalellepiped(40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xDDDDDD }));
			ground[0].castShadow = false;
			ground[0].receiveShadow = true;
			ground[0].material.color.setHex(0x888888);

			// create fake walls

			//createParalellepiped(40, 40, 1, 0, new THREE.Vector3(0, 30, -25), quat, new THREE.MeshPhongMaterial({ color: 0x333333 }));

			createEye();
			pos.y = 15;
			quat.set(0, 0, 0, 1);

			// Create soft volumes
			let thing = createSoftVolume(initialMesh.geometry, 900, 40);
			theThings.push(thing);

			// ^ Could maybe this then be disposed here safely?
		}

		function processGeometry(bufGeometry) {

			// Ony consider the position values when merging the vertices
			let posOnlyBufGeometry = new THREE.BufferGeometry();
			posOnlyBufGeometry.addAttribute('position', bufGeometry.getAttribute('position'));
			posOnlyBufGeometry.setIndex(bufGeometry.getIndex());

			// Merge the vertices so the triangle soup is converted to indexed triangles
			let indexedBufferGeom = THREE.BufferGeometryUtils.mergeVertices(posOnlyBufGeometry);

			// Create index arrays mapping the indexed vertices to bufGeometry vertices
			mapIndices(bufGeometry, indexedBufferGeom);

			posOnlyBufGeometry.dispose();
			posOnlyBufGeometry = null;
		}

		function isEqual(x1, y1, z1, x2, y2, z2) {

			const delta = 0.000001;
			return Math.abs(x2 - x1) < delta &&
				Math.abs(y2 - y1) < delta &&
				Math.abs(z2 - z1) < delta;

		}

		function mapIndices(bufGeometry, indexedBufferGeom) {

			// Creates ammoVertices, ammoIndices and ammoIndexAssociation in bufGeometry

			let vertices = bufGeometry.attributes.position.array;
			let idxVertices = indexedBufferGeom.attributes.position.array;
			let indices = indexedBufferGeom.index.array;

			const numIdxVertices = idxVertices.length / 3;
			const numVertices = vertices.length / 3;

			bufGeometry.ammoVertices = idxVertices;
			bufGeometry.ammoIndices = indices;
			bufGeometry.ammoIndexAssociation = [];

			for (let i = 0; i < numIdxVertices; i++) {

				let association = [];
				bufGeometry.ammoIndexAssociation.push(association);

				const i3 = i * 3;

				for (let j = 0; j < numVertices; j++) {

					const j3 = j * 3;
					if (isEqual(idxVertices[i3], idxVertices[i3 + 1], idxVertices[i3 + 2],
						vertices[j3], vertices[j3 + 1], vertices[j3 + 2])) {

						association.push(j3);

					}

				}

			}

		}

		function createSoftVolume(bufferGeom, mass, pressure) {

			processGeometry(bufferGeom);

			let volume = new THREE.Mesh(bufferGeom, volumeMat);
			volume.castShadow = true;
			volume.receiveShadow = true;
			volume.frustumCulled = false;
			scene.add(volume);

			// Volume physic object

			let volumeSoftBody = softBodyHelpers.CreateFromTriMesh(
				physicsWorld.getWorldInfo(),
				bufferGeom.ammoVertices,
				bufferGeom.ammoIndices,
				bufferGeom.ammoIndices.length / 3,
				true);

			let sbConfig = volumeSoftBody.get_m_cfg();
			sbConfig.set_viterations(40);
			sbConfig.set_piterations(40);

			// Soft-soft and soft-rigid collisions
			sbConfig.set_collisions(0x11);

			// Friction
			sbConfig.set_kDF(0.1);
			// Damping
			sbConfig.set_kDP(0.01);
			// Pressure
			sbConfig.set_kPR(pressure);
			// Stiffness
			volumeSoftBody.get_m_materials().at(0).set_m_kLST(0.9);
			volumeSoftBody.get_m_materials().at(0).set_m_kAST(0.9);

			volumeSoftBody.setTotalMass(mass, false);
			Ammo.castObject(volumeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(margin);
			physicsWorld.addSoftBody(volumeSoftBody, 1, - 1);
			volume.userData.physicsBody = volumeSoftBody;
			// Disable deactivation
			//volumeSoftBody.setActivationState(4);

			softBodies.push(volume);

			volume.pointColor = '#18d1bd';

			return volume;
		}

		function createParalellepiped(sx, sy, sz, mass, pos, quat, material) {

			let threeObject = new THREE.Mesh(new THREE.BoxBufferGeometry(sx, sy, sz, 1, 1, 1), material);
			let shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
			shape.setMargin(margin);

			let rb = createRigidBody(threeObject, shape, mass, pos, quat);

			return [threeObject, rb];

		}

		function createParalellepiped3(threeObject, mass, pos, quat, material) {

			//var threeObject = new THREE.Mesh(new THREE.BoxBufferGeometry(sx, sy, sz, 1, 1, 1), material);
			let shape = new Ammo.btBoxShape(new Ammo.btVector3(threeObject.geometry.parameters.width * 0.5, threeObject.geometry.parameters.height * 0.5, threeObject.geometry.parameters.depth * 0.5));
			shape.setMargin(margin);

			const rb = createRigidBody(threeObject, shape, mass, pos, quat);

			return [threeObject, rb];

		}

		function createRigidBody(threeObject, physicsShape, mass, pos, quat) {

			threeObject.position.copy(pos);
			threeObject.quaternion.copy(quat);

			let transform = new Ammo.btTransform();
			transform.setIdentity();
			transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
			transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
			let motionState = new Ammo.btDefaultMotionState(transform);

			let localInertia = new Ammo.btVector3(0, 0, 0);
			physicsShape.calculateLocalInertia(mass, localInertia);

			let rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
			var body = new Ammo.btRigidBody(rbInfo);

			threeObject.userData.physicsBody = body;

			scene.add(threeObject);

			if (mass > 0) {

				rigidBodies.push(threeObject);

				// Disable deactivation
				body.setActivationState(4);
			}

			physicsWorld.addRigidBody(body);

			return body;

		}

		function initInput() {
			const but = document.getElementById('begin');
			but.addEventListener('click', letsBegin);

			const huh = document.getElementById('huh');
			huh.addEventListener('click', showCreds);

			if (isMobile === false) {
				renderer.domElement.addEventListener('dblclick', saveImage);
				document.addEventListener('keydown', handleKeydown);
			}

			document.body.classList.remove('loading');
		}

		function showCreds(e) {
			document.body.classList.add('creds');
			document.body.addEventListener('mousedown', hideCreds);
			document.body.addEventListener('touchstart', hideCreds);
			if (e.target.tagName.toLowerCase() !== "a")
				e.stopPropagation();

			const huh = document.getElementById('huh');
			huh.removeEventListener('click', showCreds);
		}

		function hideCreds(e) {
			document.body.classList.remove('creds');
			document.body.removeEventListener('mousedown', hideCreds);
			document.body.removeEventListener('touchstart', hideCreds);

			if (e.target.tagName.toLowerCase() !== "a") {
				e.stopPropagation();
			} else {
				document.location.assign(e.target.href);
			}

			const huh = document.getElementById('huh');
			huh.addEventListener('click', showCreds);
		}

		function saveImage() {
			document.body.classList.add('screenshot');

			var tcanvas = document.createElement('canvas');
			tcanvas.height = renderer.domElement.height;
			tcanvas.width = renderer.domElement.width;

			var img = new Image();
			img.onload = function () {
				tcanvas.getContext('2d').drawImage(this, 0, 0);

				// now load our watermark
				var watermark = new Image();
				watermark.onload = function () {
					// let's keep it to at most 10% of the width of the final image (if landscape) or 50% (if portrait)...
					let maxWatermarkWidth = img.width * (img.width > img.height ? .1 : .5);
					let wmWidth = this.width;
					let wmHeight = this.height;

					if (wmWidth > maxWatermarkWidth) {
						const whRatio = this.height / this.width;
						wmWidth = maxWatermarkWidth;
						wmHeight = wmWidth * whRatio;
					}

					const wmOffsetY = 10;
					const wmOffsetX = (img.width / 2) - (wmWidth / 2);

					tcanvas.getContext('2d').drawImage(this, wmOffsetX, wmOffsetY, wmWidth, wmHeight);

					tcanvas.toBlob(bb => saveAs(bb, screenshotTitles[getRandomInt(0, screenshotTitles.length - 1)] + ".png"));

					document.body.classList.remove('screenshot');

					img = null;
					watermark = null;
				};

				watermark.src = 'watermark.png';
			};
			img.src = renderer.domElement.toDataURL();
		}

		function handleMultiTouch(e) {
			if (e.type === "touchstart") {
				if (e.touches.length === 4) {
					saveImage();
				}
				if (e.touches.length === 3) {
					shiftPerspective(true);
				}
			}

			isControllingOrbit = (e.touches.length > 0) && (e.touches.length < 3);
		}

		function handleKeydown(e) {
			//console.log(e);
			switch (e.keyCode) {
				case 32: //space
					saveImage();
					break;
				case 13: //enter
					if (screenfull.enabled) {
						screenfull.request(renderer.domElement);
					}
				default:
					shiftPerspective();
			}

			e.stopPropagation();
		}

		function letsBegin() {
			if (screenfull.enabled) {
				screenfull.request(renderer.domElement);
			}

			Tone.context.resume()
			Tone.Master.volume.rampTo(-10, '1s');
			reverb.roomSize.rampTo(1, '2s')

			document.body.classList.add('start');
			window.scrollTo(0, 0);

			createObjects();

			const welcome = document.getElementById('welcome');
			welcome.parentElement.removeChild(welcome);

			animate();

			window.addEventListener('mousedown', function (event) {
				isControllingOrbit = true;

				if (!clickRequest) {

					mouseCoords.set(
						(event.clientX / window.innerWidth) * 2 - 1,
						- (event.clientY / window.innerHeight) * 2 + 1
					);

					clickRequest = true;

				}

			}, false);

			window.addEventListener('mouseup', function (event) {
				isControllingOrbit = false;
			});
		}

		function processClick() {

			if (clickRequest) {

				const azimuthDiff = startingAzimuth - controls.getAzimuthalAngle();

				// So, the Y gravity will remain as-is. But X and Z will change with angle.
				gravX = (azimuthDiff * 3);
				gravZ = 1;

				//console.log(camera.position);
				gravX = camera.position.x / -10;
				gravZ = camera.position.z / -10;

				// Limit sideways gravitation to +/- 5.
				if (gravX < -3) gravX = -3;
				if (gravX > 3) gravX = 3;
				if (gravZ < -3) gravZ = -3;
				if (gravZ > 3) gravZ = 3;

				physicsWorld.setGravity(new Ammo.btVector3(gravX, gravityConstant, gravZ));
				physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(gravX, gravityConstant, gravZ));

				//console.log('grav: ' + gravX + ',' + gravZ);

				clickRequest = false;
			}
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
			composer.setSize(window.innerWidth, window.innerHeight);
		}

		var tcollision = false;
		function trackIntersectingPoints(collisionObject, y) {

			// How much of a margin do we want?
			const play = .1;
			const stageXZrange = 20; // absolute value; within what X,Z do we want to consider points

			if (collisionObject.hasOwnProperty('collided') == false)
				collisionObject.collided = false;

			// I guess this is neccesary to get the current data (or not...?)
			//collisionObject.updateMatrix();

			// Initalize collisionObject.trackedPointIndicies if not already
			if (collisionObject.hasOwnProperty('trackedPointIndicies') === false) {
				collisionObject.trackedPointIndicies = [];
			}

			let vec = new THREE.Vector3();
			let attribute = collisionObject.geometry.attributes.position; // we want the position data
			for (let i = 0; i < collisionObject.geometry.attributes.position.count; i++) {
				vec.fromBufferAttribute(attribute, i); // extract the x,y,z coordinates
				vec.applyMatrix4(collisionObject.matrix); // apply the mesh's matrix transform
				if (Math.abs(y - vec.y) < play && Math.abs(vec.x) < stageXZrange && Math.abs(vec.z) < stageXZrange) {
					//add the current point to teh tracking array
					if (collisionObject.trackedPointIndicies.includes(i) === false) {
						collisionObject.trackedPointIndicies.push(i);
					}
					//emit event if this is the first of any to collide
					let firstToCollide = false;
					if (tcollision === false) {
						tcollision = true;
						firstToCollide = true;
						++collisionCount;
						//console.log('xxx');
						//window.dispatchEvent(new Event('collision'));

						physicsWorld.setGravity(slowGravity);
						physicsWorld.getWorldInfo().set_m_gravity(slowGravity);

						// at low framerates, the afterimage can make things too blank
						if (FPSactual < 10)
							afterimagePass.uniforms["damp"].value = .9;
						else if (FPSactual < 20)
							afterimagePass.uniforms["damp"].value = .98;
						else
							afterimagePass.uniforms["damp"].value = .999;

						volumeMatOld.opacity = volumeMat.opacity;

						if (collisionCount % 10 == 0)
							halftonePass.uniforms.greyscale.value = !halftonePass.uniforms.greyscale.value;
					}
					//now track this particular one
					if (collisionObject.collided === false) {
						collisionObject.collided = true;
						//console.log('new thing hit at ' + vec.x + ' ' + vec.z);
						window.dispatchEvent(new CustomEvent('collision', { detail: { co: collisionObject, at: vec, first: firstToCollide } }));
					}
				}
				// capture current position of all tracked points
				if (collisionObject.trackedPointIndicies.includes(i)) {
					// capture this moment in time
					let e = vec.clone();
					e.o = collisionObject.pointColor;
					intersectionals.push(e);
				}
			}
		}

		function markIntersectingPoints(collisionObject, y) {
			// How much of a margin do we want? (For detection in the y axis)
			const play = .1;

			// I guess this is neccesary to get the current data
			collisionObject.updateMatrix();

			var vec = new THREE.Vector3();
			var attribute = collisionObject.geometry.attributes.position; // we want the position data
			for (let i = 0; i < collisionObject.geometry.attributes.position.count; i++) {
				vec.fromBufferAttribute(attribute, i); // extract the x,y,z coordinates
				vec.applyMatrix4(collisionObject.matrix); // apply the mesh's matrix transform
				if (Math.abs(y - vec.y) < play && Math.abs(vec.x) < 20 && Math.abs(vec.z) < 20) { // "20" keeps it more or less within bounds of the stage
					var e = vec.clone();
					e.o = collisionObject.pointColor;
					intersectionals.push(e);
				}
			}
		}

		var cutSectionals;
		function winnowIntersectionals() {
			const tolerance = 1;
			const minPointsTogether = 3;

			//console.log('before: ' + intersectionals.length);

			//Try to find each intersectional's nearest neighbor, and if that's larger than TOLERANCE, remove it
			for (let i = 0; i < intersectionals.length; i++) {
				let shortestDistance = Infinity;
				let pointsUnderTolerance = 0;
				intersectionals[i].d = 0;
				for (let j = 0; j < intersectionals.length; j++) {
					if (i === j)
						continue;

					const x1 = intersectionals[i].x;
					const x2 = intersectionals[j].x;
					const y1 = intersectionals[i].y;
					const y2 = intersectionals[j].y;
					const z1 = intersectionals[i].z;
					const z2 = intersectionals[j].z;

					var dist = Math.pow(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2) + Math.pow((z2 - z1), 2), .5);

					intersectionals[i].d += dist;

					if (dist < shortestDistance) {
						shortestDistance = dist;
					}

					if (dist < tolerance)
						++pointsUnderTolerance;
				}
			}

			// Now that we have an aggregate distance weight, let's get rid of any that are the furthest away
			intersectionals.sort((a, b) => a.d - b.d);

			// Keep the bottom 50%, subtract the bottom 5%
			const toKeep = Math.round(intersectionals.length * .8);
			const toCutout = Math.round(intersectionals.length * .2);
			cutSectionals = intersectionals.slice(0, toCutout);
			intersectionals.splice(toKeep, intersectionals.length - toKeep);



			/*for (var i = 0; i < intersectionals.length; i++) {
				if (intersectionals[i].d > 2000)
					intersectionals.splice(i, 1);
					//console.log('its ' + intersectionals[i].d);
			}*/
			//intersectionals = cutSectionals;
			//console.log('after: ' + intersectionals.length);
		}

		function roundAndRemoveDupes() {

			// reduce to four significant digits
			intersectionals.map(function (i) {
				i.x = Math.round(i.x * 100) / 100;
				i.y = Math.round(i.y * 100) / 100;
				i.z = Math.round(i.z * 100) / 100;
			});

			// remove dupes
			intersectionals = intersectionals.filter((thing, index, self) =>
				index === self.findIndex((t) => (
					t.x === thing.x && t.y === thing.y && t.z === thing.z
				))
			)
		}

		var intersectionalGroups = [];
		function winnowIntersectionals2() {
			const groupMinimumSize = 5;
			const groupingThreshold = 10; // The max distance between any two points for them to be "grouped"
			const maximumShortestDistance = 2; // The max distance from any other point above which we cull the point; in other words, how much of an outlier this point is

			//console.log('before: ' + intersectionals.length);

			//1. Calculate delta D for all points P
			for (let i = 0; i < intersectionals.length; i++) {
				var shortestDistance = Infinity;
				intersectionals[i].dt = 0;
				for (let j = 0; j < intersectionals.length; j++) {
					if (i === j)
						continue;

					const x1 = intersectionals[i].x;
					const x2 = intersectionals[j].x;
					const y1 = intersectionals[i].y;
					const y2 = intersectionals[j].y;
					const z1 = intersectionals[i].z;
					const z2 = intersectionals[j].z;

					const dist = Math.pow(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2) + Math.pow((z2 - z1), 2), .5);

					intersectionals[i].dt += dist;

					if (dist < shortestDistance) {
						shortestDistance = dist;
					}
				}
				intersectionals[i].da = intersectionals[i].dt / intersectionals.length;
				intersectionals[i].d = shortestDistance;
			}

			// Sort the result to have lowest delta D first
			intersectionals.sort((a, b) => a.d - b.d);

			//2. Take the point with lowest delta D as a starting point
			let pointWithLowestDeltaD = intersectionals[0];

			//3. Group with other nearby points
			let intersectionalGroup = [];
			intersectionalGroup.push(pointWithLowestDeltaD);
			intersectionals.splice(0, 1);
			for (let j = 0; j < intersectionals.length; j++) {

				const x1 = pointWithLowestDeltaD.x;
				const x2 = intersectionals[j].x;
				const y1 = pointWithLowestDeltaD.y;
				const y2 = intersectionals[j].y;
				const z1 = pointWithLowestDeltaD.z;
				const z2 = intersectionals[j].z;

				const dist = Math.pow(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2) + Math.pow((z2 - z1), 2), .5);

				if (dist <= groupingThreshold) {
					intersectionalGroup.push(intersectionals[j])
					intersectionals.splice(j, 1);
					--j;
				}
			}

			if (intersectionalGroup.length > groupMinimumSize)
				intersectionalGroups.push(intersectionalGroup);

			//console.log('after: ' + intersectionals.length + ' (' + intersectionalGroup.length + ' grouped)');
			//console.log('groups: ' + intersectionalGroups.length);
			// If we still have some points that we haven't grouped yet, and they are under the maxDistance, then do all the above again, recursively
			if (intersectionals.length > 0 && intersectionals[0].d < maximumShortestDistance)
				winnowIntersectionals2();
		}


		var points = [];
		function drawIntersectionals() {
			if (points.length > 0) {
				points.forEach(function (p) {
					scene.remove(p);
					p.material.dispose();
					p.geometry.dispose();
					p = null;
				});
			}
			points = [];

			//var loader = new THREE.TextureLoader();
			//var texture = loader.load( 'textures/sprites/snowflake7_alpha.png' );

			const allIntersections = [].concat.apply([], intersectionalGroups);
			// Group the points by color
			//console.log(allIntersections);
			const pointsByStyle = groupBy(allIntersections, 'o');
			//console.log('hh');
			//console.log(pointsByStyle);
			for (var key in pointsByStyle) {
				//console.log('h');
				//console.log(key);
				const pointsMaterial = new THREE.PointsMaterial({ color: key, size: .5, sizeAttenuation: true, alphaTest: 0.3 });
				const pointsGeometry = new THREE.BufferGeometry().setFromPoints(pointsByStyle[key]);
				const p = new THREE.Points(pointsGeometry, pointsMaterial);
				points.push(p);
				scene.add(p);
			}

			//remove ground
			setTimeout(function () {
				physicsWorld.removeRigidBody(ground[1], true);
				//scene.remove(ground[0]);
				//ground[0].geometry.dispose();
				//ground[0].material.dispose();
			}, 1000);

			// recreate ground once thing has passed
			setTimeout(function () {
				pos.set(0, -1, 0);
				quat.set(0, 0, 0, 1);
				//the below seems to not be destroyed on each turn... why?
				//ground = createParalellepiped(40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xDDDDDD }));
				ground = createParalellepiped3(ground[0], 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xDDDDDD }));
				//ground[0].castShadow = false;
				//ground[0].receiveShadow = true;
				//ground[0].material.color.setHex(0x888888);

				//physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant*-1, 0));
				//physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, gravityConstant*-1, 0));

			}, 3500);
		}

		var frst = true;
		var theOldThings = [];
		function solidifyIntersectionals3() {
			// Remove the old things
			theThings.forEach(function (t) {
				t.material = volumeMatOld;
			});
			theOldThings.push(theThings);
			// Upon having more than two "old things", remove the oldest
			if (theOldThings.length > 2) {
				theOldThings[0].forEach(function (t) {
					t.geometry.dispose();
					scene.remove(t);
					physicsWorld.removeSoftBody(t.userData.physicsBody, true);
					softBodies.splice(softBodies.indexOf(t), 1);
					t = null;
				});
				theOldThings.shift();
			}

			theThings = [];

			// Create the new things
			let geometries = [];
			let itemsWithinStage = 0;
			intersectionalGroups.forEach(function (g) {
				//console.log('solidifying...');
				//console.log(g);

				//Method one: convex geometry
				var cmeshGeometry = new THREE.ConvexBufferGeometry(g);
				//var cmeshMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff, opacity: 1, transparent: true });
				var cmesh = new THREE.Mesh(cmeshGeometry, volumeMat);

				//cmesh.position.set(0, 30, 0);
				cmesh.position.y = 60;
				//mesh.rotation.set(.5, 0, 0);

				// offset the new thing to account for any sideways gravitational forces
				cmesh.position.x -= gravX * 3;
				cmesh.position.z -= gravZ * 3;

				// apply the transform
				cmesh.updateMatrix();
				cmesh.geometry.applyMatrix(cmesh.matrix);

				THREE.BufferGeometryUtils.mergeVertices(cmeshGeometry);

				// calculate their center
				cmesh.geometry.computeBoundingBox();
				const center = new THREE.Vector3();
				cmesh.geometry.boundingBox.getCenter(center);
				cmesh.localToWorld(center);
				cmesh.geometry.worldcenter = center;
				if (center.x < 15 && center.x > -15 && center.z < 15 && center.z > -15)
					++itemsWithinStage;

				// strike a high note for each thing
				//playNoteFromXZ(cmesh.position.x, cmesh.position.z, notemaphi, 0.1, false);

				geometries.push(cmeshGeometry);
				//meshes.push(cmesh);
			});

			//console.log(itemsWithinStage + ' of ' + geometries.length + ' within stage');
			const avgX = geometries.reduce((a, c) => a + c.worldcenter.x, 0) / geometries.length;
			const avgZ = geometries.reduce((a, c) => a + c.worldcenter.z, 0) / geometries.length;
			//console.log(avgX + ',' + avgZ);
			if (itemsWithinStage <= (geometries.length - itemsWithinStage)) {
				let shiftX = 0;
				let shiftZ = 0;
				if (avgX < -15 || avgX > 15)
					shiftX = (avgX % 15) + ((Math.floor(avgX / 15) - (avgX > 0 ? 1 : -1)) * 15);
				if (avgZ < -15 || avgZ > 15)
					shiftZ = (avgZ % 15) + ((Math.floor(avgZ / 15) - (avgZ > 0 ? 1 : -1)) * 15);

				// the above will land the center within the stage, but let's push it a couple notches further
				if (shiftX > 0) shiftX += 1;
				else if (shiftX < 0) shiftX -= 1;
				if (shiftZ > 0) shiftZ += 1;
				else if (shiftZ < 0) shiftZ -= 1;

				//console.log('shifting to center by ' + shiftX + ',' + shiftZ + '...');

				// subtract shift amounts from each geometry
				geometries.forEach(function (g) {
					g.translate(shiftX * -1, 0, shiftZ * -1);
				});
			}

			// wait for the thing to pass below the stage and recreate it
			setTimeout(function () {
				geometries.forEach(function (g) {
					let thing = createSoftVolume(g, 200, .1);
					theThings.push(thing);
					//console.log('added thing');
				});

				createEye(theThings[0]);
			}, 4000);

			//reset everyting
			setTimeout(function () {
				//console.log('resetting');
				intersectionals = [];
				intersectionalGroups = [];
				tcollision = false;

				physicsWorld.setGravity(normalGravity);
				physicsWorld.getWorldInfo().set_m_gravity(normalGravity);
				frst = true;
			}, 4100);
		}

		function dripPoints() {
			points.forEach(function (p) {
				p.position.y -= .05;
				p.scale.z += .002;
				p.scale.x += .002;
				//p.updateMatrix();
				p.material.size -= .005;

			});
			afterimagePass.uniforms["damp"].value -= 0.00025;
			volumeMatOld.opacity -= .004;
		}

		var fr = 1;
		var tw = 0;
		const targetFPS = 28;
		const minInterval = 1 / targetFPS;
		var FPSdelta = 0; // running time between frames
		var FPSelapsed = 0; // the time since the last "second" rolled over
		var FPScurrent = 0; // the number of frames in the current period of 1s
		var FPSactual = targetFPS;  // the number of frames in the last period of 1s

		function animate() {
			requestAnimationFrame(animate);

			const timeSinceLastAnimateFrame = clockFPS.getDelta();
			FPSdelta += timeSinceLastAnimateFrame; // (seconds)

			// have we reached the min delay to hit the target FPS?
			if (FPSdelta >= minInterval) {
				render();
				findIntersections();

				++FPScurrent; // incriment the FPS counter
				FPSdelta -= minInterval; // subtract the reached interval from ongoing sum
			}

			// figure out the current FPS, if elapsed >= 1s
			FPSelapsed += timeSinceLastAnimateFrame;
			if (FPSelapsed >= 1) {
				FPSactual += FPScurrent;
				FPSactual /= 2;

				FPScurrent = 0;
				FPSelapsed -= 1;
			}
		}

		function findIntersections() {
			// Mark any intersecting points
			let frameFreq = (FPSactual <= 14 ? 2 : 3);

			if (fr++ % frameFreq == 0) {
				fr = 1;
				if (intersectionals !== null) {
					if (intersectionals.length < 2000) {
						theThings.forEach(function (t) {
							trackIntersectingPoints(t, 3);
						});
						for (let t = 0; t < 2; t++) {
							if (eye[t])
								trackIntersectingPoints(eye[t], 1);
						}
					} else {
						roundAndRemoveDupes();
						winnowIntersectionals2();
						drawIntersectionals();
						solidifyIntersectionals3();
						tw = 1000;
						intersectionals = null;
					}
				}
				if (points.length > 0 && tw > 0) {
					dripPoints();
					--tw;
				}
			}
		}

		function shiftPerspective(force) {
			if (isControllingOrbit === false || force === true) {
				let pos = cameraPositions[getRandomInt(0, cameraPositions.length - 1)];
				camera.position.set(pos.x, pos.y, pos.z);
				controls.update();
			}
		}

		function render() {
			const deltaTime = clock.getDelta();

			// Make thing face camera
			//for (var i = 0, il = cameraFacingThings.length; i < il; i++) {
			//	cameraFacingThings[i].lookAt(camera.position);
			//}

			updatePhysics(deltaTime);

			processClick();

			// the below add shaders
			//renderer.render(scene, camera);
			composer.render(deltaTime);

			return deltaTime;
		}

		function updatePhysics(deltaTime) {

			// Step world
			physicsWorld.stepSimulation(deltaTime, 10);

			// Update soft volumes
			for (let i = 0, il = softBodies.length; i < il; i++) {

				let volume = softBodies[i];
				let geometry = volume.geometry;
				let softBody = volume.userData.physicsBody;
				let volumePositions = geometry.attributes.position.array;
				let volumeNormals = geometry.attributes.normal.array;
				let association = geometry.ammoIndexAssociation;
				let numVerts = association.length;
				let nodes = softBody.get_m_nodes();
				for (let j = 0; j < numVerts; j++) {

					let node = nodes.at(j);
					let nodePos = node.get_m_x();
					let x = nodePos.x();
					let y = nodePos.y();
					let z = nodePos.z();
					let nodeNormal = node.get_m_n();
					let nx = nodeNormal.x();
					let ny = nodeNormal.y();
					let nz = nodeNormal.z();

					let assocVertex = association[j];

					for (let k = 0, kl = assocVertex.length; k < kl; k++) {

						var indexVertex = assocVertex[k];
						volumePositions[indexVertex] = x;
						volumeNormals[indexVertex] = nx;
						indexVertex++;
						volumePositions[indexVertex] = y;
						volumeNormals[indexVertex] = ny;
						indexVertex++;
						volumePositions[indexVertex] = z;
						volumeNormals[indexVertex] = nz;

					}

				}

				geometry.attributes.position.needsUpdate = true;
				geometry.attributes.normal.needsUpdate = true;

			}

			// Update rigid bodies
			for (let i = 0, il = rigidBodies.length; i < il; i++) {

				let objThree = rigidBodies[i];
				let objPhys = objThree.userData.physicsBody;
				let ms = objPhys.getMotionState();
				if (ms) {

					ms.getWorldTransform(transformAux1);
					let p = transformAux1.getOrigin();
					let q = transformAux1.getRotation();
					objThree.position.set(p.x(), p.y(), p.z());
					objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());

				}

			}

		}

	</script>

</body>
</html>
