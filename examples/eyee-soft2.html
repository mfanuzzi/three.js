<html lang="en">
<head>
	<title>MFMFMFMFS LSOOOOO</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		@font-face{font-family:Adventor;src:url(https://lazerbea.ms/fonts/texgyreadventor-regular-webfont.woff) format("woff");font-weight:400;font-style:normal}
		@font-face{font-family:Adventor;src:url(https://lazerbea.ms/fonts/texgyreadventor-italic-webfont.woff) format("woff");font-weight:400;font-style:italic}
		@font-face{font-family:Adventor;src:url(https://lazerbea.ms/fonts/texgyreadventor-bold-webfont.woff) format("woff");font-weight:700;font-style:normal}
		@font-face{font-family:Adventor;src:url(https://lazerbea.ms/fonts/texgyreadventor-bolditalic-webfont.woff) format("woff");font-weight:700;font-style:italic}

		body {
			color: #000;
			font-family: 'Century Gothic',Adventor,sans-serif;
			font-size: 28px;
			text-align: center;
			background-color: #fff;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {
			color: #a06851;
		}

		#container {
			width: 100%; height: 100%;
		}
		#welcome {
			width: 100%; height: 100%;
			display: flex;
			flex-direction: column;
			filter: grayscale(1);
		}
		#welcome:after {
			display: block;
			width: 100%;
			height: 100%;
			position: absolute;
			content: '';
			background: linear-gradient(#fff, #9198e5);
			opacity: .3;
		}
		#welcome > div  {
			height: 50%;
		}
		#logo {
			background: url('https://lazerbea.ms/img/logo.svg') no-repeat bottom right;
			background-size: fit;
		}
		#loadin {
			background-color: #d21888;
		}

	</style>
</head>
<body>
	<div id="container">
		<div id="welcome">
			<div id="logo"></div>
			<div id="loadin">
				<p><strong>LB011</strong>
				<br />&ldquo;the forever-falls&rdquo;</p>
			</div>
		</div>
	</div>

	<script src="../build/three.js"></script>
	<script src="js/libs/ammo.js"></script>
	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/utils/BufferGeometryUtils.js"></script>
	<script src="js/WebGL.js"></script>
	<script src="js/loaders/GLTFLoader.js"></script>
	<script src="js/libs/stats.min.js"></script>
	<script src="js/postprocessing/EffectComposer.js"></script>
	<script src="js/postprocessing/RenderPass.js"></script>
	<script src="js/postprocessing/ShaderPass.js"></script>
	<script src="js/postprocessing/HalftonePass.js"></script>
	<script src="js/postprocessing/AfterimagePass.js"></script>

	<script src="js/shaders/CopyShader.js"></script>
	<script src="js/shaders/HalftoneShader.js"></script>
	<script src="js/shaders/DepthLimitedBlurShader.js"></script>
	<script src="js/shaders/UnpackDepthRGBAShader.js"></script>
	<script src="js/shaders/AfterimageShader.js"></script>

	<script src="js/geometries/ConvexGeometry.js"></script>
	<script src="js/math/ConvexHull.js"></script>
	<script src="js/QuickHull.js"></script>

	<script src="js/modifiers/SimplifyModifier.js"></script>

	<script src="js/csg.js"></script>
	<script src="js/ThreeCSG.js"></script>

	<script src="rayintersect.js"></script>

	<script src="js/tone.js"></script>
	<script src="js/teoria.js"></script>

	<script>

		if (THREE.WEBGL.isWebGLAvailable() === false) {

			document.body.appendChild(THREE.WEBGL.getWebGLErrorMessage());
			document.getElementById('container').innerHTML = "";

		}

		// Graphics variables
		var container, stats;
		var camera, controls, scene, renderer;
		var textureLoader;
		var clock = new THREE.Clock();
		var clickRequest = false;
		var mouseCoords = new THREE.Vector2();
		var raycaster = new THREE.Raycaster();
		var ballMaterial = new THREE.MeshPhongMaterial({ color: 0x202020 });
		var volumeMat, volumeMatOld;
		var pos = new THREE.Vector3();
		var quat = new THREE.Quaternion();

		// Physics variables
		var gravityConstant = -13;
		var gravX = 0;
		var gravZ = 0;
		var physicsWorld;
		var rigidBodies = [];
		var softBodies = [];
		var margin = 0.05;
		var transformAux1;
		var softBodyHelpers;
		var composer, renderPass, halftonePass, afterimagePass, params;
		var cameraFacingThings = [];

		var theThings = [];
		var ground;
		var eye = [null, null, null, null];
		var eyeTexture;

		var intersectionals = [];

		var startingAzimuth = 0;

		var collisionCount = 0;

		var lastX = 0;
		var lastY = 0;
		function handleOrientation(event) {
			// Range of beta/gamma is -180 to 180
			var x = event.gamma;  // In degree in the range [-180,180] -- up/down
			var y = event.beta; // In degree in the range [-90,90] -- left/right

			//output.innerHTML  = "beta : " + x + "\n";
			//output.innerHTML += "gamma: " + y + "\n";

			// Because we don't want to have the device upside down
			// We constrain the x value to the range [-90,90]
			if (x > 90) { x = 90 };
			if (x < -90) { x = -90 };
			if (y > 90) { y = 90 };
			if (y < -90) { y = -90 };

			x = x * (Math.PI / 180);
			y = y * (Math.PI / 180);

			var diff = Math.abs(lastX) - Math.abs(x);
			if (x < 0)
				controls.rotateL(-diff);
			else
				controls.rotateL(diff);

			var diff = Math.abs(lastY) - Math.abs(y);
			if (y < 0)
				controls.rotateU(-diff);
			else
				controls.rotateU(diff);

			lastX = x;
			lastY = y;
		}

		//version one: 3 half-steps clockwise out from center
		//const notemap = [
		//	['F3','F#3','G3','G#3','A4','A#4'],
		//	['E3','D#2','E2','F2','F#2','B4'],
		//	['D#3','D2','A2','A#2','G2','C4'],
		//	['D3','C#2','C2','B2','G#2','C#4'],
		//	['C#3','C3','B3','A#3','A3','D4'],
		//	['G#4','G4','F#4','F4','E4','D#4']
		//];

		//v2: skipping up-to-right, meh
		//const notemap = [
		//	['A2','C3','F2','G#3','A4','A#4'],
		//	['A3','C2','F3','G#2','F#2','B4'],
		//	['B2','D3','G2','D#3','G2','C4'],
		//	['B3','D2','G3','D#2','G#2','C#4'],
		//	['C#2','E3','A#2','F#3','A3','D4'],
		//	['C#3','E2','A#3','F#2','E4','D#4']
		//];

		//v3: chromatic at edges, Fmaj7 center, minor filling
		var notemap = [
			['A3', 'A#3', 'B3', 'C3', 'C#3', 'D3'],
			['E3', 'G4', 'D4', 'A4', 'E4', 'D#3'],
			['D#', 'C4', 'E5', 'F5', 'B4', 'E3'],
			['D3', 'F4', 'C5', 'A5', 'F#4', 'F3'],
			['C#3', 'A#4', 'D#4', 'G#4', 'C#4', 'F#3'],
			['C3', 'B3', 'A#3', 'A3', 'G#3', 'G3']
		];
		var notemaphi = [
			['A7', 'A#7', 'B7', 'C7', 'C#7', 'D7'],
			['E7', 'G6', 'D6', 'A6', 'E6', 'D#7'],
			['D#', 'C6', 'E7', 'F7', 'B6', 'E7'],
			['D7', 'F6', 'C7', 'A7', 'F#6', 'F7'],
			['C#7', 'A#6', 'D#6', 'G#6', 'C#6', 'F#7'],
			['C7', 'B7', 'A#7', 'A7', 'G#7', 'G7']
		];


		var lastCollisionTimeout = null;
		var synth;
		function handleCollision(event) {
			// Determine the "volume" of the geometry to set how much velocity the hit should have
			if (event.detail.co.geometry.boundingBox == null)
				event.detail.co.geometry.computeBoundingBox();
			const bbSize = event.detail.co.geometry.boundingBox.getSize();
			const bbVol = bbSize.x * bbSize.y * bbSize.z;

			let bbNoteVel = (bbVol / 1000);
			if (bbNoteVel > 1) bbNoteVel = 1;
			if (bbNoteVel < .1) bbNoteVel = .1;

			if (Math.ceil(collisionCount / 10) % 2 === 0) {
				playNoteFromXZ(event.detail.at.x, event.detail.at.z, notemap, bbNoteVel, true, synth, ((collisionCount % 10) / 10) * 3 + .1);
			}

			// perhaps every cycle of 10x2, we should shuffle the pitches?
			if (collisionCount % 20 === 0) {
				setTimeout(function () { synth.releaseAll(); }, 4000);
				determineNewPitches();
			}

			// the below ensures that we have a way to auto-reset even if everything falls off the stage
			if (lastCollisionTimeout)
				clearTimeout(lastCollisionTimeout);

			lastCollisionTimeout = setTimeout(handleCollisionTimeout, 20000);
		}

		// This is basically to ensure that if the thing misses the stage completely, we have a way of getting it running again
		function handleCollisionTimeout() {
			createEye();
		}

		const sixnotechords = [
			'sus2#5b11',
			'maj11',
			'sus12maj9',
			'min11b5',
			'#12'
		];
		function getRandomInt(min, max) {
			min = Math.ceil(min);
			max = Math.floor(max);
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}
		function determineNewPitches() {
			// Make the whole stage one scale
			var tonic = new teoria.note(notemap[2][2]);
			if (tonic.key() > 60) 
				tonic = teoria.note.fromKey(tonic.key() - 12);
			for (var i = 0; i < notemap.length; i++) {
				const scale = tonic.scale('phrygian').notes();
				for (var j = 0; j < notemap[i].length; j++) {
					notemap[i][j] = scale[getRandomInt(0,6)].toString();
				}
			}


			//// Take the middle note as the future tonic (TODO: instead make this the most popular note maybe?)
			////const tonic = new teoria.note(notemap[2][2]);

			//for (var i = 0; i < notemap.length; i++) {
			//	var tonic = new teoria.note(notemap[i][2]);
			//	if (tonic.key() > 72) //g#6
			//		tonic = teoria.note.fromKey(tonic.key() - 24);
			//	console.log(tonic);
			//	const scale = tonic.chord(sixnotechords[getRandomInt(0, sixnotechords.length - 1)]).notes();
			//	console.log(scale);
			//	for (var j = 0; j < notemap[i].length; j++) {
			//		notemap[i][j] = scale[j].toString();
			//	}
			//}

			// Make the 'hi' version that is just the above + 2 octaves
			for (var i = 0; i < notemap.length; i++) {
				for (var j = 0; j < notemap[i].length; j++) {
					var t = new teoria.note(notemap[i][j]);
					notemaphi[i][j] = teoria.note.fromKey(t.key() + 24).toString()
				}
			}

			//// Raise everything by a M2
			//for (var i = 0; i < notemap.length; i++) {
			//	for (var j = 0; j < notemap[i].length; j++) {
			//		var t = teoria.note(notemap[i][j]);
			//		notemap[i][j] = t.interval('M2').toString();
			//		notemaphi[i][j] = t.interval('M16').toString();
			//	}
			//}
		}

		function playNoteFromXZ(x, z, nmap, velocity, detune, syn, sec) {
			let eX = Math.round((x / 20) * 3);
			let eZ = Math.round((z / 20) * 3);

			eX += 2; //2 instead of 3 because zero-based array
			eZ += 2;

			if (eX > nmap.length - 1) eX = nmap.length - 1;
			if (eZ > nmap.length - 1) eZ = nmap.length - 1;
			if (eX < 0) eX = 0;
			if (eZ < 0) eZ = 0;

			//console.log(eX + ',' + eZ + ' from ' + x + ',' + z);

			syn.set("detune", 0);
			syn.triggerAttackRelease(nmap[eX][eZ], sec + 's', null, velocity);

			if (detune === true) {
				setTimeout(function () {
					syn.set("detune", -200, 10);
				}, 2000);
			}
		}

		window.addEventListener('deviceorientation', handleOrientation);

		window.addEventListener('collision', handleCollision);


		Ammo().then(function (AmmoLib) {

			Ammo = AmmoLib;

			init();
			animate();

		});

		function groupBy(objectArray, property) {
			return objectArray.reduce(function (acc, obj) {
				var key = obj[property];
				if (!acc[key]) {
					acc[key] = [];
				}
				acc[key].push(obj);
				return acc;
			}, {});
		}

		function init() {
			let reverb = new Tone.JCReverb(.9);
			let wide = new Tone.StereoWidener(.8).toMaster();
			let narrow = new Tone.StereoWidener(.2).toMaster();
			synth = new Tone.PolySynth(5, Tone.Synth).chain(narrow);
			synth2 = new Tone.PolySynth(5, Tone.Synth).chain(wide);
			synth2.voices.forEach(v => v.portamento = 1);

			synth.volume = -8;
			synth2.volume = -2;
			let masterCompressor = new Tone.Compressor({
				"threshold": -6,
				"ratio": 8,
				"attack": 0.5,
				"release": 0.1
			});
			Tone.Master.chain(reverb, masterCompressor);
			Tone.Master.volume.value = -10; // without setting this, Chrome seems to crack up. like, too much.

			initGraphics();

			initPhysics();

			createObjects();

			initInput();

		}

		function initGraphics() {

			container = document.getElementById('container');
			container.innerHTML = '';

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);

			camera.position.set(-4, 70, 10);
			//camera.rotation.set()
			//camera.rotation.order = 'YXZ';
			//camera.rotation.x = -1.5;

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			container.appendChild(renderer.domElement);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target.set(0, -10, 0);
			controls.update();
			startingAzimuth = controls.getAzimuthalAngle();
			//controls.enabled = false;
			controls.enableZoom = true;
			controls.enablePan = false;
			controls.maxDistance = 120;
			controls.minDistance = 30;

			// Load textures
			textureLoader = new THREE.TextureLoader();
			eyeTexture = textureLoader.load("textures/eye.jpg");

			// Material for soft bodies
			volumeMat = new THREE.MeshLambertMaterial({ color: 0x55eeff, opacity: 0.5, transparent: true }); //old
			//var volumeMat = new THREE.MeshPhongMaterial({ color: 0x00ffff, opacity: 0.5, transparent: true, shininess : 100 });
			volumeMatOld = volumeMat.clone();
			textureLoader.load("textures/eye.jpg", function (texture) {

				volumeMat.map = texture;
				volumeMat.map.offset.x = .25;
				volumeMat.map.offset.y = .1;
				//volume.material.needsUpdate = true;
				//console.log(volume.material);
				volumeMatOld.map = volumeMat.map;

			});

			var ambientLight = new THREE.AmbientLight(0xaaaaaa);
			scene.add(ambientLight);

			var light = new THREE.DirectionalLight(0xffffff, 10); //light intensity
			light.position.set(- 10, 30, 5);
			light.castShadow = true;
			let d = 20;
			light.shadow.camera.left = - d;
			light.shadow.camera.right = d;
			light.shadow.camera.top = d;
			light.shadow.camera.bottom = - d;

			light.shadow.camera.near = 2;
			light.shadow.camera.far = 50;

			light.shadow.mapSize.x = 1024;
			light.shadow.mapSize.y = 1024;

			scene.add(light);

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild(stats.domElement);


			window.addEventListener('resize', onWindowResize, false);

			// post-processing
			composer = new THREE.EffectComposer(renderer);
			renderPass = new THREE.RenderPass(scene, camera);
			params = {
				shape: 1,
				radius: 3,
				rotateR: Math.PI / 12,
				rotateB: Math.PI / 12 * 2,
				rotateG: Math.PI / 12 * 3,
				scatter: 0,
				blending: .2,
				blendingMode: 2,
				greyscale: true,
				disable: false
			};
			halftonePass = new THREE.HalftonePass(window.innerWidth, window.innerHeight, params);
			composer.addPass(renderPass);
			composer.addPass(halftonePass);
			afterimagePass = new THREE.AfterimagePass();
			composer.addPass(afterimagePass);


		}

		function initPhysics() {

			// Physics configuration

			var collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
			var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
			var broadphase = new Ammo.btDbvtBroadphase();
			var solver = new Ammo.btSequentialImpulseConstraintSolver();
			var softBodySolver = new Ammo.btDefaultSoftBodySolver();
			physicsWorld = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
			physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant, 0));
			physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, gravityConstant, 0));

			transformAux1 = new Ammo.btTransform();
			softBodyHelpers = new Ammo.btSoftBodyHelpers();

		}

		function createEye(meshToTarget) {
			// Create rigid eye
			var eyeMass = .5;
			var eyeRadius = 2;

			// remove last round's old eyes
			if (eye[2] !== null && eye[3] !== null) {
				scene.remove(eye[2]);
				scene.remove(eye[3]);
				physicsWorld.removeRigidBody(eye[2].userData.physicsBody, true);
				physicsWorld.removeRigidBody(eye[3].userData.physicsBody, true);
				rigidBodies.splice(rigidBodies.indexOf(eye[2]), 1);
				rigidBodies.splice(rigidBodies.indexOf(eye[3]), 1);
				eye[2].geometry.dispose();
				eye[3].geometry.dispose();
			}

			// save old eyes
			eye[3] = eye[1];
			eye[2] = eye[0];

			for (var i = 0; i < 2; i++) {
				eye[i] = new THREE.Mesh(new THREE.SphereBufferGeometry(eyeRadius, 24, 10), new THREE.MeshPhongMaterial({ color: 0xFFFFFF }));
				eye[i].pointColor = '#ff0427';
				eye[i].scale.x = 1.7;
				//eye[i].rotateOnAxis(.1);
				eye[i].castShadow = true;
				eye[i].receiveShadow = false;
				eye[i].material.map = eyeTexture;
				eye[i].material.map.offset.x = .25;
				eye[i].material.map.offset.y = .1;
				eye[i].material.needsUpdate = true;
				var eyeShape = new Ammo.btSphereShape(eyeRadius);
				eyeShape.setMargin(margin);

				var ipos = new THREE.Vector3();
				var iquat = new THREE.Quaternion();
				ipos.set(0, 20, 0);
				//iquat.set(0, 0, .25 * (i % 2 === 0 ? -1 : 1), 1);
				iquat.set(0, 0, 0, 1);

				if (meshToTarget) {
					meshToTarget.geometry.computeBoundingBox();
					var center = new THREE.Vector3();
					meshToTarget.geometry.boundingBox.getCenter(center);
					meshToTarget.localToWorld(center);
					ipos = center;
					ipos.y = 95;
				}

				// space out the second eye
				ipos.y += (1.2 * i);
				ipos.x += (6.5 * i);
				ipos.z += (1.3 * i);

				var eyeBody = createRigidBody(eye[i], eyeShape, eyeMass, ipos, iquat);
				eyeBody.setFriction(0.8);
				eyeBody.applyLocalTorque(new Ammo.btVector3(0,0,3 * (i % 2 === 0 ? -1 : 1)))

				playNoteFromXZ(ipos.x, ipos.z, notemaphi, 0.1, false, synth2, 8);
			}

			//cameraFacingThings.push(eyeBody);
		}

		function createObjects() {

			var mat = new THREE.ShaderMaterial({
				uniforms: {},
				vertexShader: [
					"varying vec2 vUV;",
					"varying vec3 vNormal;",
					"void main() {",
					"vUV = uv;",
					"vNormal = vec3( normal );",
					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
					"}"
				].join("\n"),
				fragmentShader: [
					"varying vec2 vUV;",
					"varying vec3 vNormal;",
					"void main() {",
					"vec4 c = vec4( abs( vNormal ) + vec3( vUV, 0.0 ), 0.0 );",
					"gl_FragColor = c;",
					"}"
				].join("\n")
			});


			// Ground (hard)
			pos.set(0, -1, 0);
			quat.set(0, 0, 0, 1);
			ground = createParalellepiped(40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xDDDDDD }));
			ground[0].castShadow = false;
			ground[0].receiveShadow = true;
			ground[0].material.color.setHex(0x888888);

			// create fake walls

			//createParalellepiped(40, 40, 1, 0, new THREE.Vector3(0, 30, -25), quat, new THREE.MeshPhongMaterial({ color: 0x333333 }));



			createEye();
			pos.y = 25;
			quat.set(0, 0, 0, 1);

			// Create soft volumes
			var volumeMass = 15;

			var loader = new THREE.GLTFLoader();

			loader.load("models/gltf/eyees.glb", function (gltf) {

				//mesheye = gltf.scene.children[3];
				//scene.add( mesheye );


				mesh = gltf.scene.children[2];
				mesh.position.set(2, 60, 0);
				//mesh.position.y = 30;
				mesh.scale.set(5, 5, 5);
				mesh.rotation.set(1, 0, 0);

				// apply the transform
				mesh.updateMatrix();
				mesh.geometry.applyMatrix(mesh.matrix);
				mesh.scale.set(1, 1, 1);
				mesh.updateMatrix();

				var thing = createSoftVolume(mesh.geometry, 900, 40);
				theThings.push(thing);

			});


		}

		function processGeometry(bufGeometry) {

			// Ony consider the position values when merging the vertices
			var posOnlyBufGeometry = new THREE.BufferGeometry();
			posOnlyBufGeometry.addAttribute('position', bufGeometry.getAttribute('position'));
			posOnlyBufGeometry.setIndex(bufGeometry.getIndex());

			// Merge the vertices so the triangle soup is converted to indexed triangles
			var indexedBufferGeom = THREE.BufferGeometryUtils.mergeVertices(posOnlyBufGeometry);

			// Create index arrays mapping the indexed vertices to bufGeometry vertices
			mapIndices(bufGeometry, indexedBufferGeom);

			posOnlyBufGeometry.dispose();
		}

		function isEqual(x1, y1, z1, x2, y2, z2) {

			var delta = 0.000001;
			return Math.abs(x2 - x1) < delta &&
				Math.abs(y2 - y1) < delta &&
				Math.abs(z2 - z1) < delta;

		}

		function mapIndices(bufGeometry, indexedBufferGeom) {

			// Creates ammoVertices, ammoIndices and ammoIndexAssociation in bufGeometry

			var vertices = bufGeometry.attributes.position.array;
			var idxVertices = indexedBufferGeom.attributes.position.array;
			var indices = indexedBufferGeom.index.array;

			var numIdxVertices = idxVertices.length / 3;
			var numVertices = vertices.length / 3;

			bufGeometry.ammoVertices = idxVertices;
			bufGeometry.ammoIndices = indices;
			bufGeometry.ammoIndexAssociation = [];

			for (var i = 0; i < numIdxVertices; i++) {

				var association = [];
				bufGeometry.ammoIndexAssociation.push(association);

				var i3 = i * 3;

				for (var j = 0; j < numVertices; j++) {

					var j3 = j * 3;
					if (isEqual(idxVertices[i3], idxVertices[i3 + 1], idxVertices[i3 + 2],
						vertices[j3], vertices[j3 + 1], vertices[j3 + 2])) {

						association.push(j3);

					}

				}

			}

		}

		function createSoftVolume(bufferGeom, mass, pressure) {

			processGeometry(bufferGeom);

			var volume = new THREE.Mesh(bufferGeom, volumeMat);
			volume.castShadow = true;
			volume.receiveShadow = true;
			volume.frustumCulled = false;
			scene.add(volume);

			// Volume physic object

			var volumeSoftBody = softBodyHelpers.CreateFromTriMesh(
				physicsWorld.getWorldInfo(),
				bufferGeom.ammoVertices,
				bufferGeom.ammoIndices,
				bufferGeom.ammoIndices.length / 3,
				true);

			var sbConfig = volumeSoftBody.get_m_cfg();
			sbConfig.set_viterations(40);
			sbConfig.set_piterations(40);

			// Soft-soft and soft-rigid collisions
			sbConfig.set_collisions(0x11);

			// Friction
			sbConfig.set_kDF(0.1);
			// Damping
			sbConfig.set_kDP(0.01);
			// Pressure
			sbConfig.set_kPR(pressure);
			// Stiffness
			volumeSoftBody.get_m_materials().at(0).set_m_kLST(0.9);
			volumeSoftBody.get_m_materials().at(0).set_m_kAST(0.9);

			volumeSoftBody.setTotalMass(mass, false);
			Ammo.castObject(volumeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(margin);
			physicsWorld.addSoftBody(volumeSoftBody, 1, - 1);
			volume.userData.physicsBody = volumeSoftBody;
			// Disable deactivation
			//volumeSoftBody.setActivationState(4);

			softBodies.push(volume);

			volume.pointColor = '#18d1bd';

			return volume;
		}

		function createParalellepiped(sx, sy, sz, mass, pos, quat, material) {

			var threeObject = new THREE.Mesh(new THREE.BoxBufferGeometry(sx, sy, sz, 1, 1, 1), material);
			var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
			shape.setMargin(margin);

			var rb = createRigidBody(threeObject, shape, mass, pos, quat);

			return [threeObject, rb];

		}

		function createParalellepiped3(threeObject, mass, pos, quat, material) {

			//var threeObject = new THREE.Mesh(new THREE.BoxBufferGeometry(sx, sy, sz, 1, 1, 1), material);
			var shape = new Ammo.btBoxShape(new Ammo.btVector3(threeObject.geometry.parameters.width * 0.5, threeObject.geometry.parameters.height * 0.5, threeObject.geometry.parameters.depth * 0.5));
			shape.setMargin(margin);

			var rb = createRigidBody(threeObject, shape, mass, pos, quat);

			return [threeObject, rb];

		}

		function createRigidBody(threeObject, physicsShape, mass, pos, quat) {

			threeObject.position.copy(pos);
			threeObject.quaternion.copy(quat);

			var transform = new Ammo.btTransform();
			transform.setIdentity();
			transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
			transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
			var motionState = new Ammo.btDefaultMotionState(transform);

			var localInertia = new Ammo.btVector3(0, 0, 0);
			physicsShape.calculateLocalInertia(mass, localInertia);

			var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
			var body = new Ammo.btRigidBody(rbInfo);

			threeObject.userData.physicsBody = body;

			scene.add(threeObject);

			if (mass > 0) {

				rigidBodies.push(threeObject);

				// Disable deactivation
				body.setActivationState(4);

			}

			physicsWorld.addRigidBody(body);

			return body;

		}

		function initInput() {

			window.addEventListener('mousedown', function (event) {

				if (!clickRequest) {

					mouseCoords.set(
						(event.clientX / window.innerWidth) * 2 - 1,
						- (event.clientY / window.innerHeight) * 2 + 1
					);

					clickRequest = true;

				}

			}, false);

		}

		function processClick() {

			if (clickRequest) {

				var azimuthDiff = startingAzimuth - controls.getAzimuthalAngle();

				// So, the Y gravity will remain as-is. But X and Z will change with angle.
				gravX = (azimuthDiff * 3);
				gravZ = 1;

				console.log(camera.position);
				gravX = camera.position.x / -10;
				gravZ = camera.position.z / -10;

				// Limit sideways gravitation to +/- 5.
				if (gravX < -5) gravx = -3;
				if (gravX > 5) gravx = 3;
				if (gravZ < -5) gravz = -3;
				if (gravZ > 5) gravz = 3;

				physicsWorld.setGravity(new Ammo.btVector3(gravX, gravityConstant, gravZ));
				physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(gravX, gravityConstant, gravZ));

				//raycaster.setFromCamera(mouseCoords, camera);

				//// Creates a ball
				//var ballMass = 3;
				//var ballRadius = 0.4;

				//ball = new THREE.Mesh(new THREE.SphereBufferGeometry(ballRadius, 18, 16), ballMaterial);
				//ball.castShadow = true;
				//ball.receiveShadow = true;

				//var ballShape = new Ammo.btSphereShape(ballRadius);
				//ballShape.setMargin(margin);
				//pos.copy(raycaster.ray.direction);
				//pos.add(raycaster.ray.origin);
				//quat.set(0, 0, 0, 1);
				//var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);
				//ballBody.setFriction(0.5);

				//pos.copy(raycaster.ray.direction);
				//pos.multiplyScalar(14);
				//ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));

				clickRequest = false;

			}

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		var tcollision = false;
		function trackIntersectingPoints(collisionObject, y) {

			// How much of a margin do we want?
			var play = .1;

			if (collisionObject.hasOwnProperty('collided') == false)
				collisionObject.collided = false;

			// I guess this is neccesary to get the current data
			collisionObject.updateMatrix();

			// Initalize collisionObject.trackedPointIndicies if not already
			if (collisionObject.hasOwnProperty('trackedPointIndicies') === false) {
				collisionObject.trackedPointIndicies = [];
			}

			var vec = new THREE.Vector3();
			var attribute = collisionObject.geometry.attributes.position; // we want the position data
			for (var i = 0; i < collisionObject.geometry.attributes.position.count; i++) {
				vec.fromBufferAttribute(attribute, i); // extract the x,y,z coordinates
				vec.applyMatrix4(collisionObject.matrix); // apply the mesh's matrix transform
				if (Math.abs(y - vec.y) < play && Math.abs(vec.x) < 20 && Math.abs(vec.z) < 20) {
					//add the current point to teh tracking array
					if (collisionObject.trackedPointIndicies.includes(i) === false) {
						collisionObject.trackedPointIndicies.push(i);
					}
					//emit event if this is the first of any to collide
					if (tcollision === false) {
						tcollision = true;
						++collisionCount;
						//console.log('xxx');
						//window.dispatchEvent(new Event('collision'));
						//// undo this
						physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant / 3, 0));
						physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, gravityConstant / 3, 0));

						afterimagePass.uniforms["damp"].value = .999;

						volumeMatOld.opacity = volumeMat.opacity;

						if (collisionCount % 10 == 0)
							halftonePass.uniforms.greyscale.value = !halftonePass.uniforms.greyscale.value;
					}
					//now track this particular one
					if (collisionObject.collided === false) {
						collisionObject.collided = true;
						//console.log('new thing hit at ' + vec.x + ' ' + vec.z);
						window.dispatchEvent(new CustomEvent('collision', { detail: { co: collisionObject, at: vec } }));
					}
				}
				// capture current position of all tracked points
				if (collisionObject.trackedPointIndicies.includes(i)) {
					// capture this moment in time
					var e = vec.clone();
					e.o = collisionObject.pointColor;
					intersectionals.push(e);
				}
			}
		}

		function markIntersectingPoints(collisionObject, y) {
			// How much of a margin do we want? (For detection in the y axis)
			var play = .1;

			// I guess this is neccesary to get the current data
			collisionObject.updateMatrix();

			var vec = new THREE.Vector3();
			var attribute = collisionObject.geometry.attributes.position; // we want the position data
			for (var i = 0; i < collisionObject.geometry.attributes.position.count; i++) {
				vec.fromBufferAttribute(attribute, i); // extract the x,y,z coordinates
				vec.applyMatrix4(collisionObject.matrix); // apply the mesh's matrix transform
				if (Math.abs(y - vec.y) < play && Math.abs(vec.x) < 20 && Math.abs(vec.z) < 20) { // "20" keeps it more or less within bounds of the stage
					var e = vec.clone();
					e.o = collisionObject.pointColor;
					intersectionals.push(e);
				}
			}
		}

		var cutSectionals;
		function winnowIntersectionals() {
			var tolerance = 1;
			var minPointsTogether = 3;

			//console.log('before: ' + intersectionals.length);

			//Try to find each intersectional's nearest neighbor, and if that's larger than TOLERANCE, remove it
			for (var i = 0; i < intersectionals.length; i++) {
				var shortestDistance = Infinity;
				var pointsUnderTolerance = 0;
				intersectionals[i].d = 0;
				for (var j = 0; j < intersectionals.length; j++) {
					if (i === j)
						continue;

					var x1 = intersectionals[i].x;
					var x2 = intersectionals[j].x;
					var y1 = intersectionals[i].y;
					var y2 = intersectionals[j].y;
					var z1 = intersectionals[i].z;
					var z2 = intersectionals[j].z;

					var dist = Math.pow(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2) + Math.pow((z2 - z1), 2), .5);

					intersectionals[i].d += dist;

					if (dist < shortestDistance) {
						shortestDistance = dist;
					}

					if (dist < tolerance)
						++pointsUnderTolerance;
				}
			}

			// Now that we have an aggregate distance weight, let's get rid of any that are the furthest away
			intersectionals.sort((a, b) => a.d - b.d);

			// Keep the bottom 50%, subtract the bottom 5%
			var toKeep = Math.round(intersectionals.length * .8);
			var toCutout = Math.round(intersectionals.length * .2);
			cutSectionals = intersectionals.slice(0, toCutout);
			intersectionals.splice(toKeep, intersectionals.length - toKeep);



			/*for (var i = 0; i < intersectionals.length; i++) {
				if (intersectionals[i].d > 2000)
					intersectionals.splice(i, 1);
					//console.log('its ' + intersectionals[i].d);
			}*/
			//intersectionals = cutSectionals;
			//console.log('after: ' + intersectionals.length);
		}

		function roundAndRemoveDupes() {

			// reduce to four significant digits
			intersectionals.map(function (i) {
				i.x = Math.round(i.x * 100) / 100;
				i.y = Math.round(i.y * 100) / 100;
				i.z = Math.round(i.z * 100) / 100;
			});

			// remove dupes
			intersectionals = intersectionals.filter((thing, index, self) =>
				index === self.findIndex((t) => (
					t.x === thing.x && t.y === thing.y && t.z === thing.z
				))
			)
		}

		var intersectionalGroups = [];
		function winnowIntersectionals2() {
			var groupMinimumSize = 5;
			var groupingThreshold = 10; // The max distance between any two points for them to be "grouped"
			var maximumShortestDistance = 2; // The max distance from any other point above which we cull the point; in other words, how much of an outlier this point is

			//console.log('before: ' + intersectionals.length);

			//1. Calculate delta D for all points P
			for (var i = 0; i < intersectionals.length; i++) {
				var shortestDistance = Infinity;
				intersectionals[i].dt = 0;
				for (var j = 0; j < intersectionals.length; j++) {
					if (i === j)
						continue;

					var x1 = intersectionals[i].x;
					var x2 = intersectionals[j].x;
					var y1 = intersectionals[i].y;
					var y2 = intersectionals[j].y;
					var z1 = intersectionals[i].z;
					var z2 = intersectionals[j].z;

					var dist = Math.pow(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2) + Math.pow((z2 - z1), 2), .5);

					intersectionals[i].dt += dist;

					if (dist < shortestDistance) {
						shortestDistance = dist;
					}
				}
				intersectionals[i].da = intersectionals[i].dt / intersectionals.length;
				intersectionals[i].d = shortestDistance;
			}

			// Sort the result to have lowest delta D first
			intersectionals.sort((a, b) => a.d - b.d);

			//2. Take the point with lowest delta D as a starting point
			var pointWithLowestDeltaD = intersectionals[0];

			//3. Group with other nearby points
			var intersectionalGroup = [];
			intersectionalGroup.push(pointWithLowestDeltaD);
			intersectionals.splice(0, 1);
			for (var j = 0; j < intersectionals.length; j++) {

				var x1 = pointWithLowestDeltaD.x;
				var x2 = intersectionals[j].x;
				var y1 = pointWithLowestDeltaD.y;
				var y2 = intersectionals[j].y;
				var z1 = pointWithLowestDeltaD.z;
				var z2 = intersectionals[j].z;

				var dist = Math.pow(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2) + Math.pow((z2 - z1), 2), .5);

				if (dist <= groupingThreshold) {
					intersectionalGroup.push(intersectionals[j])
					intersectionals.splice(j, 1);
					--j;
				}
			}

			if (intersectionalGroup.length > groupMinimumSize)
				intersectionalGroups.push(intersectionalGroup);

			//console.log('after: ' + intersectionals.length + ' (' + intersectionalGroup.length + ' grouped)');
			//console.log('groups: ' + intersectionalGroups.length);
			// If we still have some points that we haven't grouped yet, and they are under the maxDistance, then do all the above again, recursively
			if (intersectionals.length > 0 && intersectionals[0].d < maximumShortestDistance)
				winnowIntersectionals2();
		}


		var points = [];
		function drawIntersectionals() {
			if (points.length > 0) {
				points.forEach(function (p) {
					scene.remove(p);
					p.material.dispose();
					p.geometry.dispose();
				});
			}
			points = [];

			//var loader = new THREE.TextureLoader();
			//var texture = loader.load( 'textures/sprites/snowflake7_alpha.png' );

			var allIntersections = [].concat.apply([], intersectionalGroups);
			// Group the points by color
			//console.log(allIntersections);
			var pointsByStyle = groupBy(allIntersections, 'o');
			//console.log('hh');
			//console.log(pointsByStyle);
			for (var key in pointsByStyle) {
				//console.log('h');
				//console.log(key);
				var pointsMaterial = new THREE.PointsMaterial({ color: key, size: .5, sizeAttenuation: true, alphaTest: 0.3 });
				var pointsGeometry = new THREE.BufferGeometry().setFromPoints(pointsByStyle[key]);
				var p = new THREE.Points(pointsGeometry, pointsMaterial);
				points.push(p);
				scene.add(p);
			}

			//remove ground
			setTimeout(function () {
				physicsWorld.removeRigidBody(ground[1], true);
				//scene.remove(ground[0]);
				//ground[0].geometry.dispose();
				//ground[0].material.dispose();
			}, 1000);

			// recreate ground once thing has passed
			setTimeout(function () {
				pos.set(0, -1, 0);
				quat.set(0, 0, 0, 1);
				//the below seems to not be destroyed on each turn... why?
				//ground = createParalellepiped(40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xDDDDDD }));
				ground = createParalellepiped3(ground[0], 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xDDDDDD }));
				//ground[0].castShadow = false;
				//ground[0].receiveShadow = true;
				//ground[0].material.color.setHex(0x888888);

				//physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant*-1, 0));
				//physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, gravityConstant*-1, 0));

			}, 3500);
		}

		var frst = true;
		var theOldThings;
		function solidifyIntersectionals3() {
			// Remove the old things
			theOldThings = theThings;
			theOldThings.forEach(function (t) {
				t.material = volumeMatOld;
			});
			setTimeout(function () {
				theOldThings.forEach(function (t) {
					t.geometry.dispose();
					scene.remove(t);
					physicsWorld.removeSoftBody(t.userData.physicsBody, true);
					softBodies.splice(softBodies.indexOf(t), 1);
				});
			}, 6000);

			theThings = [];

			// Create the new things
			var geometries = [];
			var itemsWithinStage = 0;
			intersectionalGroups.forEach(function (g) {
				//console.log('solidifying...');
				//console.log(g);

				//Method one: convex geometry
				var cmeshGeometry = new THREE.ConvexBufferGeometry(g);
				//var cmeshMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff, opacity: 1, transparent: true });
				var cmesh = new THREE.Mesh(cmeshGeometry, volumeMat);

				//cmesh.position.set(0, 30, 0);
				cmesh.position.y = 60;
				//mesh.rotation.set(.5, 0, 0);

				// offset the new thing to account for any sideways gravitational forces
				cmesh.position.x -= gravX * 3;
				cmesh.position.z -= gravZ * 3;

				// apply the transform
				cmesh.updateMatrix();
				cmesh.geometry.applyMatrix(cmesh.matrix);

				THREE.BufferGeometryUtils.mergeVertices(cmeshGeometry);

				// calculate their center
				cmesh.geometry.computeBoundingBox();
				var center = new THREE.Vector3();
				cmesh.geometry.boundingBox.getCenter(center);
				cmesh.localToWorld(center);
				cmesh.geometry.worldcenter = center;
				if (center.x < 15 && center.x > -15 && center.z < 15 && center.z > -15)
					++itemsWithinStage;

				// strike a high note for each thing
				//playNoteFromXZ(cmesh.position.x, cmesh.position.z, notemaphi, 0.1, false);

				geometries.push(cmeshGeometry);
				//meshes.push(cmesh);
			});

			//console.log(itemsWithinStage + ' of ' + geometries.length + ' within stage');
			const avgX = geometries.reduce((a, c) => a + c.worldcenter.x, 0) / geometries.length;
			const avgZ = geometries.reduce((a, c) => a + c.worldcenter.z, 0) / geometries.length;
			//console.log(avgX + ',' + avgZ);
			if (itemsWithinStage <= (geometries.length - itemsWithinStage)) {
				var shiftX = 0;
				var shiftZ = 0;
				if (avgX < -15 || avgX > 15)
					shiftX = (avgX % 15) + ((Math.floor(avgX / 15) - (avgX > 0 ? 1 : -1)) * 15);
				if (avgZ < -15 || avgZ > 15)
					shiftZ = (avgZ % 15) + ((Math.floor(avgZ / 15) - (avgZ > 0 ? 1 : -1)) * 15);

				// the above will land the center within the stage, but let's push it a couple notches further
				if (shiftX > 0) shiftX += 1;
				else if (shiftX < 0) shiftX -= 1;
				if (shiftZ > 0) shiftZ += 1;
				else if (shiftZ < 0) shiftZ -= 1;

				//console.log('shifting to center by ' + shiftX + ',' + shiftZ + '...');

				// subtract shift amounts from each geometry
				geometries.forEach(function (g) {
					g.translate(shiftX * -1, 0, shiftZ * -1);
				});
			}

			// wait for the thing to pass below the stage and recreate it
			setTimeout(function () {
				geometries.forEach(function (g) {
					var thing = createSoftVolume(g, 200, .1);
					theThings.push(thing);
					//console.log('added thing');
				});

				createEye(theThings[0]);
			}, 4000);

			//reset everyting
			setTimeout(function () {
				//console.log('resetting');
				intersectionals = [];
				intersectionalGroups = [];
				tcollision = false;

				physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant, 0));
				physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, gravityConstant, 0));
				frst = true;
			}, 4100);
		}

		function dripPoints() {
			points.forEach(function (p) {
				p.position.y -= .05;
				p.scale.z += .002;
				p.scale.x += .002;
				p.updateMatrix();
				p.material.size -= .005;
				
			});
			afterimagePass.uniforms["damp"].value -= 0.00025;
			volumeMatOld.opacity -= .004;
		}

		//function solidifyIntersectionals2() {
		//	//Method two: Manual arrangment

		//	// Sort into quadrants
		//	for (var i = 0; i < intersectionals.length; i++) {
		//		intersectionals[i].rad = Math.atan2(intersectionals[i].z, intersectionals[i].x);
		//	}

		//	//intersectionals.sort((a, b) => b.y - a.y);

		//	// Dirty thing: turn the vecsBelow into a typed array
		//	var t = new Float32Array(intersectionals.length * 3);
		//	for (var i = 0; i < t.length; i += 3) {
		//		t[i] = intersectionals[i / 3].x;
		//		t[i + 1] = intersectionals[i / 3].y;
		//		//t[i + 1] = y;
		//		t[i + 2] = intersectionals[i / 3].z;
		//	}

		//	var rgeometry = new THREE.BufferGeometry();
		//	rgeometry.addAttribute('position', new THREE.BufferAttribute(t, 3));
		//	THREE.BufferGeometryUtils.mergeVertices(rgeometry);
		//	rgeometry.computeFaceNormals();
		//	rgeometry.computeVertexNormals();

		//	var rmaterial = new THREE.MeshLambertMaterial({ color: 0xffff00, opacity: 0.9, transparent: true });
		//	var rmesh = new THREE.Mesh(rgeometry, rmaterial);
		//	//scene.add(rmesh);
		//	console.log(rmesh);

		//	setTimeout(function () {
		//		scene.remove(theThing);
		//		var thing = createSoftVolume(rgeometry, 9, 40);
		//		theThing = thing;
		//	}, 5000);

		//}

		var fr = 1;
		var tw = 0;
		function animate() {

			requestAnimationFrame(animate);

			render();

			// Mark any intersecting points
			if (fr++ % 3 == 0) {
				fr = 1;
				if (intersectionals !== null) {
					if (intersectionals.length < 2000) {
						theThings.forEach(function (t) {
							trackIntersectingPoints(t, 3);
						});
						for (var t = 0; t < 2; t++) {
							trackIntersectingPoints(eye[t], 1);
						}
					} else {
						roundAndRemoveDupes();
						winnowIntersectionals2();
						drawIntersectionals();
						solidifyIntersectionals3();
						tw = 1000;
						intersectionals = null;
					}
				}
				if (points.length > 0 && tw > 0) {
					dripPoints();
					--tw;
				}
			}

			stats.update();

		}

		function render() {

			var deltaTime = clock.getDelta();

			// Make thing face camera
			for (var i = 0, il = cameraFacingThings.length; i < il; i++) {
				cameraFacingThings[i].lookAt(camera.position);
			}


			updatePhysics(deltaTime);

			processClick();

			// the below add shaders
			renderer.render(scene, camera);
			composer.render(deltaTime);

		}

		function updatePhysics(deltaTime) {

			// Step world
			physicsWorld.stepSimulation(deltaTime, 10);

			// Update soft volumes
			for (var i = 0, il = softBodies.length; i < il; i++) {

				var volume = softBodies[i];
				var geometry = volume.geometry;
				var softBody = volume.userData.physicsBody;
				var volumePositions = geometry.attributes.position.array;
				var volumeNormals = geometry.attributes.normal.array;
				var association = geometry.ammoIndexAssociation;
				var numVerts = association.length;
				var nodes = softBody.get_m_nodes();
				for (var j = 0; j < numVerts; j++) {

					var node = nodes.at(j);
					var nodePos = node.get_m_x();
					var x = nodePos.x();
					var y = nodePos.y();
					var z = nodePos.z();
					var nodeNormal = node.get_m_n();
					var nx = nodeNormal.x();
					var ny = nodeNormal.y();
					var nz = nodeNormal.z();

					var assocVertex = association[j];

					for (var k = 0, kl = assocVertex.length; k < kl; k++) {

						var indexVertex = assocVertex[k];
						volumePositions[indexVertex] = x;
						volumeNormals[indexVertex] = nx;
						indexVertex++;
						volumePositions[indexVertex] = y;
						volumeNormals[indexVertex] = ny;
						indexVertex++;
						volumePositions[indexVertex] = z;
						volumeNormals[indexVertex] = nz;

					}

				}

				geometry.attributes.position.needsUpdate = true;
				geometry.attributes.normal.needsUpdate = true;

			}

			// Update rigid bodies
			for (var i = 0, il = rigidBodies.length; i < il; i++) {

				var objThree = rigidBodies[i];
				var objPhys = objThree.userData.physicsBody;
				var ms = objPhys.getMotionState();
				if (ms) {

					ms.getWorldTransform(transformAux1);
					var p = transformAux1.getOrigin();
					var q = transformAux1.getRotation();
					objThree.position.set(p.x(), p.y(), p.z());
					objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());

				}

			}

		}

	</script>

</body>
</html>
